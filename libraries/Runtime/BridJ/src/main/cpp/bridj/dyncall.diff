Index: ~/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_gas.S
===================================================================
--- ~/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_gas.S	
+++ ~/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_gas.S	
@@ -95,21 +95,25 @@
 
 	// handle return value
 
+	cmp %al, 'v'
+	je .return_void
 	cmp %al, 'd'
 	je .return_f64
 	cmp %al, 'f'
 	je .return_f32
 	cmp %al, 'l'
 	je .return_i64
-	cmp %al, 'i'
-	je .return_i32
-	ret
+	cmp %al, 'L'
+	je .return_i64_
+	
+	// All int cases <= 32 bits (+ pointer & string cases) fall in the 32 bits int case
 
 .return_i32:
 	mov  %eax, [%edx]
 	ret
 
 .return_i64:
+.return_i64_:
 	mov  %eax, [%edx]
 	mov  %edx, [%edx+4]
 	ret
@@ -121,3 +125,6 @@
 .return_f64:
 	fld qword ptr [%edx]
 	ret
+
+.return_void:
+  	ret
Index: ~/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_masm.asm
===================================================================
--- ~/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_masm.asm	
+++ ~/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_masm.asm	
@@ -93,16 +93,19 @@
   mov  ebp, [ebp]                    ; EBP = parent frame
 
   ; handle return value
+  
+  cmp al, 'v'
+  je return_void
   cmp al, 'd'
   je return_f64
   cmp al, 'f'
   je return_f32
   cmp al, 'l'
   je return_i64
-  cmp al, 'i'
-  je return_i32
-  ret
-
+  cmp al, 'L'
+  je return_i64
+  ; All int cases <= 32 bits (+ pointer & string cases) fall in the 32 bits int case
+  
 return_i32:
   mov  eax, [edx]
   ret
@@ -120,6 +123,9 @@
   fld qword ptr [edx]
   ret
 
+return_void:
+  ret
+
 _dcCallbackThunkEntry ENDP
 
 END
Index: ~/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_apple.s
===================================================================
--- ~/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_apple.s	
+++ ~/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_apple.s	
@@ -44,10 +44,12 @@
 frame_DCArgs       = -24
 frame_DCValue      = -32
 
+ASCII_L = 76
 ASCII_l = 108
 ASCII_d	= 100
 ASCII_f = 102
 ASCII_i = 105
+ASCII_v = 118
 
 _dcCallbackThunkEntry:
 	push %ebp
@@ -96,21 +98,25 @@
 
 	// handle return value
 
+	cmp %al, ASCII_v
+	je .return_void
 	cmp %al, ASCII_d
 	je .return_f64
 	cmp %al, ASCII_f
 	je .return_f32
 	cmp %al, ASCII_l
 	je .return_i64
-	cmp %al, ASCII_i
-	je .return_i32
-	ret
+	cmp %al, ASCII_L
+	je .return_i64_
+	
+	// All int cases <= 32 bits (+ pointer & string cases) fall in the 32 bits int case	
 
 .return_i32:
 	mov  %eax, [%edx]
 	ret
 
 .return_i64:
+.return_i64_:
 	mov  %eax, [%edx]
 	mov  %edx, [%edx+4]
 	ret
@@ -122,3 +128,6 @@
 .return_f64:
 	fld qword ptr [%edx]
 	ret
+
+.return_void:
+	ret
Index: ~/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_n64.c
===================================================================
--- ~/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_n64.c	
+++ ~/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_n64.c	
@@ -190,6 +190,7 @@
 , &dc_callvm_argFloat_mips_n64
 , &dc_callvm_argDouble_mips_n64
 , &dc_callvm_argPointer_mips_n64
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_mips_n64
 , (DCboolvmfunc*)       &dc_callvm_call_mips_n64
 , (DCcharvmfunc*)       &dc_callvm_call_mips_n64
@@ -200,6 +201,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_mips_n64
 , (DCdoublevmfunc*)     &dc_callvm_call_mips_n64
 , (DCpointervmfunc*)    &dc_callvm_call_mips_n64
+, NULL // argStruct
 };
 
 DCCallVM_vt gVT_mips_n64_ellipsis =
Index: ~/src/dyncall/dyncall/dyncall/dyncall_vector.c
===================================================================
--- ~/src/dyncall/dyncall/dyncall/dyncall_vector.c	
+++ ~/src/dyncall/dyncall/dyncall/dyncall_vector.c	
@@ -22,14 +22,31 @@
 
 #include "dyncall_vector.h"
 #include <string.h>
+//void memcpy(void*, const void*, size_t);
 
 void dcVecAppend(DCVecHead* pHead, const void* pData, size_t size)
 {
-  if (pHead->mSize+size <= pHead->mTotal) 
+	size_t newSize = pHead->mSize + size;
+  if (newSize <= pHead->mTotal) 
   {
-    void* dst = (char*)dcVecData(pHead) + pHead->mSize;
-    memcpy(dst, pData, size); /* @@@ heavy for small types. */
-    pHead->mSize += size;
+  	void* dst = (char*)dcVecData(pHead) + pHead->mSize;
+  	switch (size) {
+  	case 1:
+  		*(char*)dst = *(const char*)pData;
+  		break;
+  	case 2:
+  		*(short*)dst = *(const short*)pData;
+  		break;
+  	case 4:
+  		*(int*)dst = *(const int*)pData;
+  		break;
+  	case 8:
+  		*(long long*)dst = *(const long long*)pData;
+  		break;
+  	default:
+  		memcpy(dst, pData, size); /* @@@ heavy for small types. */
+  	}
+    pHead->mSize = newSize;
   } 
 }
 
Index: ~/src/dyncall/dyncall/dyncall/dyncall_struct.c
===================================================================
--- ~/src/dyncall/dyncall/dyncall/dyncall_struct.c	
+++ ~/src/dyncall/dyncall/dyncall/dyncall_struct.c	
@@ -0,0 +1,193 @@
+/*
+ Package: dyncall
+ File: dyncall/dyncall_struct.c
+ Description: C interface to compute struct size
+ License:
+ Copyright (c) 2010 Olivier Chafik <olivier.chafik@centraliens.net>
+
+ Permission to use, copy, modify, and distribute this software for any
+ purpose with or without fee is hereby granted, provided that the above
+ copyright notice and this permission notice appear in all copies.
+
+ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+*/
+
+#include "dyncall.h"
+#include "dyncall_signature.h"
+#include "dyncall_struct.h"
+#include "dyncall_alloc.h"
+
+#define ASSERT(x)
+#define UNKNOWN_SIZE -1
+
+DCstruct*  dcNewStruct(DCsize fieldCount, DCint alignment) {
+	DCstruct* s = (DCstruct*)dcAllocMem(sizeof(DCstruct));
+	s->pCurrentStruct = s;
+	s->pLastStruct = NULL;
+	s->currentField = 0;
+	s->fieldCount = fieldCount;
+	s->alignment = alignment;
+	s->size = UNKNOWN_SIZE;
+	s->pFields = (DCfield*)dcAllocMem(fieldCount * sizeof(DCfield));
+	return s;
+}
+void dcStructField(DCstruct* s, DCint type, DCint alignment, DCsize arrayLength) {
+	DCfield *f = s->pCurrentStruct->pFields + (s->pCurrentStruct->currentField++);
+	f->type = type;
+	f->arrayLength = arrayLength;
+	f->pSubStruct = NULL;
+	switch (type) {
+    case DC_SIGCHAR_BOOL:       f->size = sizeof(DCbool); break;
+    case DC_SIGCHAR_CHAR:       
+    case DC_SIGCHAR_UCHAR:      f->size = sizeof(DCchar); break;
+    case DC_SIGCHAR_SHORT:      
+    case DC_SIGCHAR_USHORT:     f->size = sizeof(DCshort); break;
+    case DC_SIGCHAR_INT:        
+    case DC_SIGCHAR_UINT:       f->size = sizeof(DCint); break;
+    case DC_SIGCHAR_LONG:       
+    case DC_SIGCHAR_ULONG:      f->size = sizeof(DClong); break;
+    case DC_SIGCHAR_LONGLONG:   
+    case DC_SIGCHAR_ULONGLONG:  f->size = sizeof(DClonglong); break;
+    case DC_SIGCHAR_FLOAT:      f->size = sizeof(DCfloat); break;
+    case DC_SIGCHAR_DOUBLE:     f->size = sizeof(DCdouble); break;
+    case DC_SIGCHAR_POINTER:
+	case DC_SIGCHAR_STRING:     f->size = sizeof(DCpointer); break;
+	default:                    ASSERT(0);
+	}
+}
+void dcSubStruct(DCstruct* s, DCsize fieldCount, DCint alignment, DCsize arrayLength) {
+	DCfield *f = s->pCurrentStruct->pFields + (s->pCurrentStruct->currentField++);
+	f->type = DC_SIGCHAR_STRUCT;
+	f->arrayLength = arrayLength;
+	f->pSubStruct = dcNewStruct(fieldCount, alignment);
+	f->pSubStruct->pLastStruct = s->pCurrentStruct;
+	s->pCurrentStruct = f->pSubStruct;
+}  	
+void dcAlign(DCsize *size, DCsize alignment) {
+	DCsize rest = alignment - ((*size) % alignment);
+	(*size) += rest;
+}
+void dcComputeStructSize(DCstruct* s) {
+	ASSERT(s);
+	DCsize i, size = 0;
+	DCsize alignment = s->alignment;
+	for (i = 0; i < s->fieldCount; i++) {
+		DCfield *f = s->pFields + i;
+		if (f->type == DC_SIGCHAR_STRUCT) {
+			dcComputeStructSize(f->pSubStruct);
+			f->size = f->pSubStruct->size;
+		}
+		if (f->size > alignment)
+			alignment = f->size;
+		
+		dcAlign(&size, f->alignment);
+		size += f->size * f->arrayLength;
+	}
+	ASSERT(s->alignment == DEFAULT_ALIGNMENT || s->alignment == alignment);
+	s->alignment = alignment;
+	
+	dcAlign(&size, alignment);
+	s->size = size;
+}
+
+// Each dcNewStruct or dcSubStruct call must be paired with a dcCloseStruct
+void dcCloseStruct(DCstruct* s) {
+	ASSERT(s->pCurrentStruct->currentField == s->pCurrentStruct->fieldCount);
+	ASSERT(s->pCurrentStruct->pLastStruct);
+	s->pCurrentStruct = s->pCurrentStruct->pLastStruct;
+	if (!s->pLastStruct)
+		dcComputeStructSize(s);
+}
+
+void dcFreeStruct(DCstruct* s) {
+	ASSERT(s);
+	DCsize i;
+	for (i = 0; i < s->fieldCount; i++) {
+		DCfield *f = s->pFields + i;
+		if (f->type == DC_SIGCHAR_STRUCT)
+			dcFreeStruct(f->pSubStruct);
+	}
+	free(s->pFields);
+	free(s);
+}
+
+void dcArgStructUnroll(DCCallVM* vm, DCstruct* s, DCpointer  value) {
+	ASSERT(s && value);
+	DCsize i;
+	for (i = 0; i < s->fieldCount; i++) {
+		DCfield *f = s->pFields + i;
+		DCpointer p = value + f->offset;
+		switch(f->type) {
+		  case DC_SIGCHAR_STRUCT:
+		  	dcArgStruct(vm, f->pSubStruct, p);
+		  	break;
+		  case DC_SIGCHAR_BOOL: 
+			dcArgBool      (vm, *(DCbool*)p); 
+			break;
+		  case DC_SIGCHAR_CHAR:
+		  case DC_SIGCHAR_UCHAR:
+			dcArgChar      (vm, *(DCchar*)p);
+			break;
+		  case DC_SIGCHAR_SHORT:
+		  case DC_SIGCHAR_USHORT:
+			dcArgShort     (vm, *(DCshort*)p);
+			break;
+		  case DC_SIGCHAR_INT:
+		  case DC_SIGCHAR_UINT:
+			dcArgInt       (vm, *(DCint*)p);
+			break;
+		  case DC_SIGCHAR_LONG:
+		  case DC_SIGCHAR_ULONG:
+			dcArgLong      (vm, *(DCulong*)p);
+			break;
+		  case DC_SIGCHAR_LONGLONG:
+		  case DC_SIGCHAR_ULONGLONG:
+			dcArgLongLong  (vm, *(DCulonglong*)p);
+			break;
+		  case DC_SIGCHAR_FLOAT:
+			dcArgFloat     (vm, *(DCfloat*)p);
+			break;
+		  case DC_SIGCHAR_DOUBLE:
+			dcArgDouble    (vm, *(DCdouble*)p);
+			break;
+		  case DC_SIGCHAR_POINTER:
+		  case DC_SIGCHAR_STRING:
+			dcArgPointer   (vm, *(DCpointer**)p);
+			break;
+	       default:
+	       	ASSERT(0);
+		}	
+	}
+}
+
+DCbool isDigit(char c) {
+	return c >= '0' && c <= '9';
+}
+DCint readInt(const char** ptr) {
+	return strtol(*ptr, ptr, 10);
+}
+
+DCstruct*  dcDefineStruct(const char* signature) {
+	DCstruct* s;
+	const char* ptr = signature;
+	DCint fieldCount = readInt(&ptr);
+	s = dcNewStruct(fieldCount, DEFAULT_ALIGNMENT);
+	
+	while (*ptr) {
+		char type = *(ptr++);
+		if (type == DC_SIGCHAR_STRUCT) {
+			//dcSubStruct(	
+		} else {
+			dcStructField(s, type, DEFAULT_ALIGNMENT, readInt(&ptr));
+		}
+	}
+	dcCloseStruct(s);
+	return s;
+}
Index: ~/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_eabi.c
===================================================================
--- ~/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_eabi.c	
+++ ~/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_eabi.c	
@@ -152,6 +152,7 @@
 , &dc_callvm_argFloat_mips_eabi
 , &dc_callvm_argDouble_mips_eabi
 , &dc_callvm_argPointer_mips_eabi
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_mips_eabi
 , (DCboolvmfunc*)       &dc_callvm_call_mips_eabi
 , (DCcharvmfunc*)       &dc_callvm_call_mips_eabi
@@ -162,6 +163,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_mips_eabi
 , (DCdoublevmfunc*)     &dc_callvm_call_mips_eabi
 , (DCpointervmfunc*)    &dc_callvm_call_mips_eabi
+, NULL // argStruct
 };
 
 DCCallVM* dcNewCallVM_mips_eabi(DCsize size) 
Index: ~/src/dyncall/dyncall/dyncall/dyncall_struct.h
===================================================================
--- ~/src/dyncall/dyncall/dyncall/dyncall_struct.h	
+++ ~/src/dyncall/dyncall/dyncall/dyncall_struct.h	
@@ -0,0 +1,64 @@
+/*
+ Package: dyncall
+ File: dyncall/dyncall_struct.h
+ Description: C interface to compute struct size
+ License:
+ Copyright (c) 2010 Olivier Chafik <olivier.chafik@centraliens.net>
+
+ Permission to use, copy, modify, and distribute this software for any
+ purpose with or without fee is hereby granted, provided that the above
+ copyright notice and this permission notice appear in all copies.
+
+ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+*/
+
+/*
+
+  dyncall struct metadata structures
+
+  REVISION
+  2007/12/11 initial
+  
+*/
+
+#ifndef DYNCALL_STRUCT_H
+#define DYNCALL_STRUCT_H
+
+#include "dyncall.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif 
+
+#ifndef DC_API
+#define DC_API
+#endif
+
+typedef struct DCfield_ {
+	DCsize offset, size, alignment, arrayLength;
+	DCint type;
+	DCstruct* pSubStruct;
+} DCfield;
+
+struct DCstruct_ {
+	DCfield *pFields;
+	DCsize size, alignment, fieldCount;
+	
+	// struct building uses a state machine :
+	DCint currentField;       // == -1 if struct is closed
+	DCstruct *pCurrentStruct, *pLastStruct; // == this, unless we're in a sub struct
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* DYNCALL_H */
+
Index: ~/src/dyncall/dyncall/dyncall/GNUmakefile
===================================================================
--- ~/src/dyncall/dyncall/dyncall/GNUmakefile	
+++ ~/src/dyncall/dyncall/dyncall/GNUmakefile	
@@ -37,6 +37,7 @@
 INSTALL_LIB = 1
 
 UNITS = dyncall_vector dyncall_api 
+UNITS += dyncall_struct
 
 # @@@ disable dyncall_callf for pcc support temporarly
 ifdef BUILD_TOOL_pcc
Index: ~/src/dyncall/dyncall/dyncall/dyncall_api.c
===================================================================
--- ~/src/dyncall/dyncall/dyncall/dyncall_api.c	
+++ ~/src/dyncall/dyncall/dyncall/dyncall_api.c	
@@ -85,6 +85,12 @@
   vm->mVTpointer->argPointer(vm,x); 
 }
 
+void dcArgStruct(DCCallVM* vm, DCstruct* s, DCpointer x) 
+{ 
+  vm->mVTpointer->argStruct(vm, s, x); 
+}
+
+
 void dcCallVoid(DCCallVM* vm, DCpointer funcptr) 
 {        
   vm->mVTpointer->callVoid(vm, funcptr); 
@@ -135,6 +141,11 @@
   return vm->mVTpointer->callPointer(vm, funcptr); 
 }
 
+void dcCallStruct(DCCallVM* vm, DCpointer funcptr, DCstruct* s, DCpointer x) 
+{ 
+  vm->mVTpointer->callStruct(vm, funcptr, s, x); 
+}
+
 DCint dcGetError(DCCallVM *vm)
 {
   return vm->mError;
Index: ~/src/dyncall/dyncall/dyncall/dyncall_callvm_x64.c
===================================================================
--- ~/src/dyncall/dyncall/dyncall/dyncall_callvm_x64.c	
+++ ~/src/dyncall/dyncall/dyncall/dyncall_callvm_x64.c	
@@ -23,8 +23,8 @@
 
 #include "dyncall_callvm_x64.h"
 #include "dyncall_alloc.h"
+#include "dyncall_struct.h"
 
-
 static DCCallVM* dc_callvm_new_x64(DCCallVM_vt* vt, DCsize size)
 {
   DCCallVM_x64* self = (DCCallVM_x64*)dcAllocMem(sizeof(DCCallVM_x64)+size);
@@ -148,7 +148,16 @@
     dcVecAppend(&self->mVecHead, &x, sizeof(DCpointer));
 }
 
+static void dc_callvm_argStruct_x64(DCCallVM* in_self, DCstruct* s, DCpointer x)
+{
+  DCCallVM_x64* self = (DCCallVM_x64*)in_self;
+  dcVecAppend(&self->mVecHead, x, s->size);
+  
+  if (s->size <= 64)
+  	  dcArgStructUnroll(in_self, s, x);
+}
 
+
 /* Call. */
 void dc_callvm_call_x64(DCCallVM* in_self, DCpointer target)
 {
@@ -183,6 +192,7 @@
 , &dc_callvm_argFloat_x64
 , &dc_callvm_argDouble_x64
 , &dc_callvm_argPointer_x64
+, &dc_callvm_argStruct_x64
 , (DCvoidvmfunc*)       &dc_callvm_call_x64
 , (DCboolvmfunc*)       &dc_callvm_call_x64
 , (DCcharvmfunc*)       &dc_callvm_call_x64
@@ -193,6 +203,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x64
 , (DCdoublevmfunc*)     &dc_callvm_call_x64
 , (DCpointervmfunc*)    &dc_callvm_call_x64
+, NULL // argStruct
 };
 
 
Index: ~/src/dyncall/dyncall/dyncall/dyncall_callvm_arm32_arm.c
===================================================================
--- ~/src/dyncall/dyncall/dyncall/dyncall_callvm_arm32_arm.c	
+++ ~/src/dyncall/dyncall/dyncall/dyncall_callvm_arm32_arm.c	
@@ -163,6 +163,7 @@
 , &dc_callvm_argFloat_arm32_arm
 , &dc_callvm_argDouble_arm32_arm
 , &dc_callvm_argPointer_arm32_arm
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_arm32_arm
 , (DCboolvmfunc*)       &dc_callvm_call_arm32_arm
 , (DCcharvmfunc*)       &dc_callvm_call_arm32_arm
@@ -173,6 +174,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_arm32_arm
 , (DCdoublevmfunc*)     &dc_callvm_call_arm32_arm
 , (DCpointervmfunc*)    &dc_callvm_call_arm32_arm
+, NULL // callStruct
 };
 
 
@@ -190,6 +192,7 @@
 , &dc_callvm_argFloat_arm32_arm
 , &dc_callvm_argDouble_arm32_arm_eabi
 , &dc_callvm_argPointer_arm32_arm
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_arm32_arm
 , (DCboolvmfunc*)       &dc_callvm_call_arm32_arm
 , (DCcharvmfunc*)       &dc_callvm_call_arm32_arm
@@ -200,6 +203,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_arm32_arm
 , (DCdoublevmfunc*)     &dc_callvm_call_arm32_arm
 , (DCpointervmfunc*)    &dc_callvm_call_arm32_arm
+, NULL // argStruct
 };
 
 
Index: ~/src/dyncall/dyncall/dyncall/dyncall_callvm.h
===================================================================
--- ~/src/dyncall/dyncall/dyncall/dyncall_callvm.h	
+++ ~/src/dyncall/dyncall/dyncall/dyncall_callvm.h	
@@ -49,6 +49,7 @@
   void         (*argFloat)       (DCCallVM* vm,DCfloat         f);
   void         (*argDouble)      (DCCallVM* vm,DCdouble        d);
   void         (*argPointer)     (DCCallVM* vm,DCpointer       p);
+  void         (*argStruct)      (DCCallVM* vm,DCstruct* s, DCpointer p);
   void         (*callVoid)       (DCCallVM* vm,DCpointer funcptr);
   DCbool       (*callBool)       (DCCallVM* vm,DCpointer funcptr);
   DCchar       (*callChar)       (DCCallVM* vm,DCpointer funcptr);
@@ -59,6 +60,7 @@
   DCfloat      (*callFloat)      (DCCallVM* vm,DCpointer funcptr);
   DCdouble     (*callDouble)     (DCCallVM* vm,DCpointer funcptr);
   DCpointer    (*callPointer)    (DCCallVM* vm,DCpointer funcptr);
+  void         (*callStruct)     (DCCallVM* vm,DCpointer funcptr,DCstruct* s, DCpointer returnValue);
 };
 
 typedef DCvoid       (DCvoidvmfunc)      (DCCallVM* vm,DCpointer funcptr); 
Index: ~/src/dyncall/dyncall/dyncall/dyncall_callvm_ppc32.c
===================================================================
--- ~/src/dyncall/dyncall/dyncall/dyncall_callvm_ppc32.c	
+++ ~/src/dyncall/dyncall/dyncall/dyncall_callvm_ppc32.c	
@@ -302,6 +302,7 @@
 , &dc_callvm_argFloat_ppc32_darwin
 , &dc_callvm_argDouble_ppc32_darwin
 , &dc_callvm_argPointer_ppc32
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_ppc32_darwin
 , (DCboolvmfunc*)       &dc_callvm_call_ppc32_darwin
 , (DCcharvmfunc*)       &dc_callvm_call_ppc32_darwin
@@ -312,6 +313,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_ppc32_darwin
 , (DCdoublevmfunc*)     &dc_callvm_call_ppc32_darwin
 , (DCpointervmfunc*)    &dc_callvm_call_ppc32_darwin
+, NULL // argStruct
 };
 
 DCCallVM_vt gVT_ppc32_sysv =
@@ -328,6 +330,7 @@
 , &dc_callvm_argFloat_ppc32_sysv
 , &dc_callvm_argDouble_ppc32_sysv
 , &dc_callvm_argPointer_ppc32
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_ppc32_sysv
 , (DCboolvmfunc*)       &dc_callvm_call_ppc32_sysv
 , (DCcharvmfunc*)       &dc_callvm_call_ppc32_sysv
@@ -338,6 +341,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_ppc32_sysv
 , (DCdoublevmfunc*)     &dc_callvm_call_ppc32_sysv
 , (DCpointervmfunc*)    &dc_callvm_call_ppc32_sysv
+, NULL // argStruct
 };
 
 void dc_callvm_mode_ppc32(DCCallVM* in_self, DCint mode)
Index: ~/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_n32.c
===================================================================
--- ~/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_n32.c	
+++ ~/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_n32.c	
@@ -190,6 +190,7 @@
 , &dc_callvm_argFloat_mips_n32
 , &dc_callvm_argDouble_mips_n32
 , &dc_callvm_argPointer_mips_n32
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_mips_n32
 , (DCboolvmfunc*)       &dc_callvm_call_mips_n32
 , (DCcharvmfunc*)       &dc_callvm_call_mips_n32
@@ -200,6 +201,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_mips_n32
 , (DCdoublevmfunc*)     &dc_callvm_call_mips_n32
 , (DCpointervmfunc*)    &dc_callvm_call_mips_n32
+, NULL // argStruct
 };
 
 DCCallVM_vt gVT_mips_n32_ellipsis =
@@ -216,6 +218,7 @@
 , &dc_callvm_argFloat_mips_n32_ellipsis
 , &dc_callvm_argDouble_mips_n32_ellipsis
 , &dc_callvm_argPointer_mips_n32
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_mips_n32
 , (DCboolvmfunc*)       &dc_callvm_call_mips_n32
 , (DCcharvmfunc*)       &dc_callvm_call_mips_n32
@@ -226,6 +229,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_mips_n32
 , (DCdoublevmfunc*)     &dc_callvm_call_mips_n32
 , (DCpointervmfunc*)    &dc_callvm_call_mips_n32
+, NULL // argStruct
 };
 
 static void dc_callvm_mode_mips_n32(DCCallVM* self,DCint mode)
Index: ~/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_o32.c
===================================================================
--- ~/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_o32.c	
+++ ~/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_o32.c	
@@ -199,6 +199,7 @@
 , &dc_callvm_argFloat_mips_o32
 , &dc_callvm_argDouble_mips_o32
 , &dc_callvm_argPointer_mips_o32
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_mips_o32
 , (DCboolvmfunc*)       &dc_callvm_call_mips_o32
 , (DCcharvmfunc*)       &dc_callvm_call_mips_o32
@@ -209,6 +210,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_mips_o32
 , (DCdoublevmfunc*)     &dc_callvm_call_mips_o32
 , (DCpointervmfunc*)    &dc_callvm_call_mips_o32
+, NULL // argStruct
 };
 
 DCCallVM* dcNewCallVM_mips_o32(DCsize size) 
Index: ~/src/dyncall/dyncall/dyncall/dyncall_signature.h
===================================================================
--- ~/src/dyncall/dyncall/dyncall/dyncall_signature.h	
+++ ~/src/dyncall/dyncall/dyncall/dyncall_signature.h	
@@ -51,7 +51,9 @@
 #define DC_SIGCHAR_DOUBLE       'd'
 #define DC_SIGCHAR_POINTER      'p'
 #define DC_SIGCHAR_STRING       'Z'
-#define DC_SIGCHAR_ENDARG       ')'
+#define DC_SIGCHAR_STRUCT       'T'
+//#define DC_SIGCHAR_ALIGN        '0' // byte value to which '0' (zero digit) will be substracted to get the alignment
+#define DC_SIGCHAR_ENDARG       ')' // also works for end struct
 
 /* callback signatures */
 
Index: ~/src/dyncall/dyncall/dyncall/dyncall_callvm_x86.c
===================================================================
--- ~/src/dyncall/dyncall/dyncall/dyncall_callvm_x86.c	
+++ ~/src/dyncall/dyncall/dyncall/dyncall_callvm_x86.c	
@@ -210,6 +210,7 @@
 , &dc_callvm_argFloat_x86
 , &dc_callvm_argDouble_x86
 , &dc_callvm_argPointer_x86
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_x86_cdecl
 , (DCboolvmfunc*)       &dc_callvm_call_x86_cdecl
 , (DCcharvmfunc*)       &dc_callvm_call_x86_cdecl
@@ -220,6 +221,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x86_cdecl
 , (DCdoublevmfunc*)     &dc_callvm_call_x86_cdecl
 , (DCpointervmfunc*)    &dc_callvm_call_x86_cdecl
+, NULL // argStruct
 };
 
 DCCallVM* dcNewCallVM_x86_cdecl(DCsize size) 
@@ -255,6 +257,7 @@
 , &dc_callvm_argFloat_x86
 , &dc_callvm_argDouble_x86
 , &dc_callvm_argPointer_x86
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_x86_win32_std
 , (DCboolvmfunc*)       &dc_callvm_call_x86_win32_std
 , (DCcharvmfunc*)       &dc_callvm_call_x86_win32_std
@@ -265,6 +268,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x86_win32_std
 , (DCdoublevmfunc*)     &dc_callvm_call_x86_win32_std
 , (DCpointervmfunc*)    &dc_callvm_call_x86_win32_std
+, NULL // argStruct
 };
 
 /* win32/std callvm allocator */
@@ -364,6 +368,7 @@
 , &dc_callvm_argFloat_x86
 , &dc_callvm_argDouble_x86
 , &dc_callvm_argPointer_x86_win32_fast_ms
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_x86_win32_fast
 , (DCboolvmfunc*)       &dc_callvm_call_x86_win32_fast
 , (DCcharvmfunc*)       &dc_callvm_call_x86_win32_fast
@@ -374,6 +379,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x86_win32_fast
 , (DCdoublevmfunc*)     &dc_callvm_call_x86_win32_fast
 , (DCpointervmfunc*)    &dc_callvm_call_x86_win32_fast
+, NULL // argStruct
 };
 
 DCCallVM* dcNewCallVM_x86_win32_fast_ms(DCsize size) 
@@ -460,6 +466,7 @@
 , &dc_callvm_argFloat_x86
 , &dc_callvm_argDouble_x86
 , &dc_callvm_argPointer_x86_win32_fast_gnu
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_x86_win32_fast
 , (DCboolvmfunc*)       &dc_callvm_call_x86_win32_fast
 , (DCcharvmfunc*)       &dc_callvm_call_x86_win32_fast
@@ -470,6 +477,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x86_win32_fast
 , (DCdoublevmfunc*)     &dc_callvm_call_x86_win32_fast
 , (DCpointervmfunc*)    &dc_callvm_call_x86_win32_fast
+, NULL // argStruct
 };
 
 DCCallVM* dcNewCallVM_x86_win32_fast_gnu(DCsize size) 
@@ -503,6 +511,7 @@
 , &dc_callvm_argFloat_x86
 , &dc_callvm_argDouble_x86
 , &dc_callvm_argPointer_x86
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_x86_win32_this_ms
 , (DCboolvmfunc*)       &dc_callvm_call_x86_win32_this_ms
 , (DCcharvmfunc*)       &dc_callvm_call_x86_win32_this_ms
@@ -513,6 +522,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x86_win32_this_ms
 , (DCdoublevmfunc*)     &dc_callvm_call_x86_win32_this_ms
 , (DCpointervmfunc*)    &dc_callvm_call_x86_win32_this_ms
+, NULL // argStruct
 };
 
 /* win32/this/ms callvm allocator */
Index: ~/src/dyncall/dyncall/dyncall/dyncall.h
===================================================================
--- ~/src/dyncall/dyncall/dyncall/dyncall.h	
+++ ~/src/dyncall/dyncall/dyncall/dyncall.h	
@@ -44,6 +44,7 @@
 #endif
 
 typedef struct DCCallVM_    DCCallVM;
+typedef struct DCstruct_    DCstruct;
 
 /* Supported Calling Convention Modes */
 
@@ -93,6 +94,7 @@
 DC_API void       dcArgFloat      (DCCallVM* vm, DCfloat    value);
 DC_API void       dcArgDouble     (DCCallVM* vm, DCdouble   value);
 DC_API void       dcArgPointer    (DCCallVM* vm, DCpointer  value);
+DC_API void       dcArgStruct     (DCCallVM* vm, DCstruct* s, DCpointer  value);
 
 DC_API void       dcCallVoid      (DCCallVM* vm, DCpointer funcptr);
 DC_API DCbool     dcCallBool      (DCCallVM* vm, DCpointer funcptr);
@@ -104,9 +106,25 @@
 DC_API DCfloat    dcCallFloat     (DCCallVM* vm, DCpointer funcptr);
 DC_API DCdouble   dcCallDouble    (DCCallVM* vm, DCpointer funcptr);
 DC_API DCpointer  dcCallPointer   (DCCallVM* vm, DCpointer funcptr);
+DC_API void       dcCallStruct    (DCCallVM* vm, DCpointer funcptr, DCstruct* s, DCpointer returnValue);
 
 DC_API DCint      dcGetError      (DCCallVM* vm);
 
+#define DEFAULT_ALIGNMENT -1
+DC_API DCstruct*  dcNewStruct     (DCsize fieldCount, DCint alignment);
+DC_API void       dcStructField   (DCstruct* s, DCint type, DCint alignment, DCsize arrayLength);
+DC_API void       dcSubStruct     (DCstruct* s, DCsize fieldCount, DCint alignment, DCsize arrayLength);  	
+// Each dcNewStruct or dcSubStruct call must be paired with a dcCloseStruct
+DC_API void       dcCloseStruct   (DCstruct* s);  	
+DC_API DCsize     dcStructSize    (DCstruct* s);  	
+DC_API DCsize     dcStructAlignment(DCstruct* s);  	
+DC_API void       dcFreeStruct    (DCstruct* s);
+
+DC_API DCstruct*  dcDefineStruct  (const char* signature);
+
+// Internal: move to some header (dyncall_structs.h for instance)
+void dcArgStructUnroll(DCCallVM* vm, DCstruct* s, DCpointer  value);
+
 #ifdef __cplusplus
 }
 #endif
Index: ~/src/dyncall/dyncall/dyncall/dyncall_call_x64_masm.asm
===================================================================
--- ~/src/dyncall/dyncall/dyncall/dyncall_call_x64_masm.asm	
+++ ~/src/dyncall/dyncall/dyncall/dyncall_call_x64_masm.asm	
@@ -49,8 +49,8 @@
 
 	sub			rsp, rcx					; Setup stack frame by subtracting the size of the arguments.
 
-	mov			rax, rcx					; Align stack.
-	add			rax, 8
+	mov         rax, rsp                    ; Align stack.
+
 	and			rax, 15
 	sub			rsp, rax
 
Index: ~/src/dyncall/dyncall/dynload/dynload_darwin.c
===================================================================
--- ~/src/dyncall/dyncall/dynload/dynload_darwin.c	
+++ ~/src/dyncall/dyncall/dynload/dynload_darwin.c	
@@ -27,7 +27,10 @@
 
 
 #include "dynload.h"
+//#include "dynload_macros.h"
+//#include "dyncall_macros.h"
 #include "dyncall_alloc.h"
+
 #include <dlfcn.h>
 #include <string.h>
 
@@ -63,7 +66,6 @@
         return lib;
 }
 
-
 void* dlFindSymbol(DLLib* libHandle, const char* symbol)
 {
   return dlsym(libHandle && libHandle->handle ? libHandle->handle : RTLD_DEFAULT, symbol);
Index: ~/src/dyncall/dyncall/dynload/dynload.h
===================================================================
--- ~/src/dyncall/dyncall/dynload/dynload.h	
+++ ~/src/dyncall/dyncall/dynload/dynload.h	
@@ -24,6 +24,9 @@
 #ifndef DYNLOAD_H
 #define DYNLOAD_H
 
+
+#include "dyncall_macros.h"
+#include "dynload_macros.h"
 #include <stddef.h>
 #include <stdlib.h>
 
@@ -31,15 +34,19 @@
 extern "C" {
 #endif
 
+#ifndef DC_API
+#define DC_API
+#endif
+
 /* --- public api ---------------------------------------------------------- */
 
 /* shared library loading and explicit symbol resolving */
 
 typedef struct DLLib_ DLLib;
 
-DLLib* dlLoadLibrary(const char* libpath);
-void   dlFreeLibrary(DLLib* pLib);
-void*  dlFindSymbol(DLLib* pLib, const char* pSymbolName);
+DC_API DLLib* dlLoadLibrary(const char* libpath);
+DC_API void   dlFreeLibrary(DLLib* pLib);
+DC_API void*  dlFindSymbol(DLLib* pLib, const char* pSymbolName);
 
 /* symbol table enumeration */
 
Index: ~/src/dyncall/dyncall/dynload/dynload_unix.h
===================================================================
--- ~/src/dyncall/dyncall/dynload/dynload_unix.h	
+++ ~/src/dyncall/dyncall/dynload/dynload_unix.h	
@@ -0,0 +1,51 @@
+/*
+ Package: dynload
+ File: include/dynload_unix.h
+ Description: Unix-specific header file for dynload
+ License:
+
+ Copyright (c) 2011      Olivier Chafik <olivier.chafik@gmail.com>
+
+ Permission to use, copy, modify, and distribute this software for any
+ purpose with or without fee is hereby granted, provided that the above
+ copyright notice and this permission notice appear in all copies.
+
+ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+*/
+
+#ifndef DYNLOAD_UNIX_H
+#define DYNLOAD_UNIX_H
+
+
+#if !defined(DC__OS_SunOS)
+/*
+ * On some platforms (all but Solaris, or so it seems), dlopen returns a struct { Elf_Ehdr* } straight away.
+ * This behaviour is undocumented but allows us to get our hands on the ELF structures easily.
+ * On the platforms that don't have this undocumented behaviour, we need to memory-map the file to inspect the ELF metadata. 
+ */
+#  define DC_DLOPEN_HACK
+#endif
+
+struct DLLib_
+{
+  // Pointer to ELF header (might or might not be the same as libHandle
+  void* pElf_Ehdr; 
+  // Library handle returned by dlopen
+  void* libHandle;
+  
+#if !defined(DC_DLOPEN_HACK)
+  // File handle of the library, as returned by open
+  int file;
+  // Size of the library file, in bytes
+  size_t fileSize;
+#endif
+};
+
+#endif // DYNLOAD_UNIX_H
Index: ~/src/dyncall/dyncall/dynload/dynload_windows.c
===================================================================
--- ~/src/dyncall/dyncall/dynload/dynload_windows.c	
+++ ~/src/dyncall/dyncall/dynload/dynload_windows.c	
@@ -32,7 +32,8 @@
 
 DLLib* dlLoadLibrary(const char* libPath)
 {
-  return (DLLib*) LoadLibraryA(libPath);
+  //return (DLLib*) LoadLibraryA(libPath);
+  return (DLLib*) LoadLibraryExA(libPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
 }
 
 void* dlFindSymbol(DLLib* libHandle, const char* symbol)
Index: ~/src/dyncall/dyncall/dynload/dynload_syms.c
===================================================================
--- ~/src/dyncall/dyncall/dynload/dynload_syms.c	
+++ ~/src/dyncall/dyncall/dynload/dynload_syms.c	
@@ -17,12 +17,15 @@
 
 */
 
+#include "dynload.h"
+#include "dynload_macros.h"
 #include "dyncall_macros.h"
+#include "dyncall_alloc.h"
 
 #if defined(DC_WINDOWS)
 #  include "dynload_syms_pe.c"
 #elif defined(DC_UNIX)
-#  if defined (DC__OS_Darwin) 
+#  if defined (DC__OS_Darwin)
 #    include "dynload_syms_mach-o.c"
 #  else
 #    include "dynload_syms_elf.c"
Index: ~/src/dyncall/dyncall/dynload/dynload_syms_mach-o.c
===================================================================
--- ~/src/dyncall/dyncall/dynload/dynload_syms_mach-o.c	
+++ ~/src/dyncall/dyncall/dynload/dynload_syms_mach-o.c	
@@ -33,9 +33,11 @@
 
 #if defined(DC__Arch_AMD64)
 #define MACH_HEADER_TYPE mach_header_64
+#define SEGMENT_COMMAND segment_command_64
 #define NLIST_TYPE nlist_64
 #else
 #define MACH_HEADER_TYPE mach_header
+#define SEGMENT_COMMAND segment_command
 #define NLIST_TYPE nlist
 #endif
 
@@ -67,8 +69,13 @@
 		const char* name = _dyld_get_image_name(iImage);
 		if (name && !strcmp(name, pLib->libPath))
 		{
-			const struct mach_header* pHeader = _dyld_get_image_header(iImage);
-			const char* pBase = (const char*)pHeader;
+			const struct MACH_HEADER_TYPE* pHeader = _dyld_get_image_header(iImage);
+			const char* pBase = ((const char*)pHeader);
+			if (pHeader->filetype != MH_DYLIB)
+				return NULL;
+			if (pHeader->flags & MH_SPLIT_SEGS)
+				return NULL;
+
 			if (pHeader)
 			{
 				uint32_t iCmd, nCmds = pHeader->ncmds;
@@ -106,7 +113,6 @@
 	dcFreeMem(pSyms);
 }
 
-
 int dlSymsCount(DLSyms* pSyms)
 {
 	if (!pSyms)
@@ -114,7 +120,6 @@
 	return pSyms->symbolCount;
 }
 
-
 static const struct NLIST_TYPE* get_nlist(DLSyms* pSyms, int index)
 {
 	const struct NLIST_TYPE* nl;
Index: ~/src/dyncall/dyncall/dynload/dynload.c
===================================================================
--- ~/src/dyncall/dyncall/dynload/dynload.c	
+++ ~/src/dyncall/dyncall/dynload/dynload.c	
@@ -18,11 +18,14 @@
 */
 
 #include "dynload.h"
+//#include "dynload_macros.h"
 #include "dyncall_macros.h"
+//#include "dyncall_alloc.h"
+
 #if defined(DC_WINDOWS)
 #  include "dynload_windows.c"
 #elif defined(DC_UNIX)
-#  if defined (DC__OS_Darwin)
+#  if defined(DC__OS_Darwin)
 #    include "dynload_darwin.c"
 #  else
 #    include "dynload_unix.c"
Index: ~/src/dyncall/dyncall/dynload/dynload_syms_elf.c
===================================================================
--- ~/src/dyncall/dyncall/dynload/dynload_syms_elf.c	
+++ ~/src/dyncall/dyncall/dynload/dynload_syms_elf.c	
@@ -20,6 +20,7 @@
 
 #if defined(DC__OS_Linux) && !defined(_GNU_SOURCE)
 #define _GNU_SOURCE
+#define __USE_GNU
 #endif
 
 /*
@@ -30,11 +31,15 @@
 
 #include "dynload.h"
 #include "dynload_macros.h"
+#include "dynload_unix.h"
 #if defined(DC__OS_OpenBSD)
 #	include <elf_abi.h>
 #else
 #	include <elf.h>
 #endif
+#if defined(DC__OS_SunOS)
+#   include <link.h>
+#endif
 #include <assert.h>
 #include <dlfcn.h>
 #include <stdio.h>
@@ -44,6 +49,7 @@
 #ifdef DL__BinaryFormat_elf64
 typedef Elf64_Ehdr   Elf_Ehdr;
 typedef Elf64_Phdr   Elf_Phdr;
+typedef Elf64_Shdr   Elf_Shdr;
 typedef Elf64_Sym    Elf_Sym;
 typedef Elf64_Dyn    Elf_Dyn;
 typedef Elf64_Sxword Elf_tag;
@@ -51,19 +57,13 @@
 #else
 typedef Elf32_Ehdr   Elf_Ehdr;
 typedef Elf32_Phdr   Elf_Phdr;
+typedef Elf32_Shdr   Elf_Shdr;
 typedef Elf32_Sym    Elf_Sym;
 typedef Elf32_Dyn    Elf_Dyn;
 typedef Elf32_Sword  Elf_tag;
 typedef Elf32_Addr   Elf_Addr;
 #endif
 
-
-struct DLLib_
-{
-  Elf_Ehdr* pElf_Ehdr;
-};
-
-
 typedef struct 
 {
   uint32_t nbucket;        
@@ -112,6 +112,9 @@
   Elf_Sym*    pSymTab;
   Elf_GNU_Hash* pGNUHash;
   uint32_t*     pGNUHashChain;
+#if !defined(DC_DLOPEN_HACK)
+  DLLib*      pLib;
+#endif
 };
 
 
@@ -128,6 +131,10 @@
   pSyms->pGNUHash = 0;
   pSyms->pGNUHashChain = 0;
 
+#if !defined(DC_DLOPEN_HACK)
+  pSyms->pLib     = pLib;
+#endif
+
   Elf_Ehdr* pH   = pLib->pElf_Ehdr;
 #ifdef DL__BinaryFormat_elf32
   assert( pH->e_ident[EI_CLASS] == ELFCLASS32 );
@@ -181,6 +188,35 @@
     uint32_t* pchain   = (uint32_t*) &pbuckets[p->nbuckets];
     pSyms->pGNUHashChain = pchain;
   }
+  
+  if (!pSyms->pHash) {
+  	/* traverse section headers */
+    Elf_Shdr* pS = (Elf_Shdr*) ( pMem + pH->e_shoff );
+    /* skip section 0 which is always zero due to the Elf standard. */
+    
+    for (i=1;i<pH->e_shnum;++i) 
+    {
+      Elf_Shdr* pSection = &pS[i];
+      
+      void* pSectionContent = ((char*)pMem) + pSection->sh_offset;
+      
+      switch( pSection->sh_type )
+      {
+        case SHT_HASH:
+          pSyms->pHash = (Elf_Hash*)pSectionContent;
+          break;
+        case SHT_DYNSYM: // only the dynamic symbols
+        //case SHT_SYMTAB: // all symbols
+          pSyms->pSymTab  = (Elf_Sym*)pSectionContent;
+          break;
+        case SHT_STRTAB:
+          // Do not trust pH->e_shstrndx !
+          if (!pSyms->pStrTab)
+          	  pSyms->pStrTab  = (const char*)pSectionContent;
+          break;
+      }
+    }  
+  }
   return pSyms;
 }
 
@@ -193,11 +229,15 @@
 
 int dlSymsCount(DLSyms* pSyms)
 {
-  if (!pSyms || !pSyms->pHash)
-    return 0;
-
-  if (pSyms->pGNUHash) {
-    return pSyms->pHash->nchain - pSyms->pGNUHash->symndx;
+  if (!pSyms || (!pSyms->pHash && !pSyms->pGNUHash))
+     return 0;
+ 
+   if (pSyms->pGNUHash) {
+	// ld option : --hash-style
+	// see http://sourceware.org/ml/binutils/2006-06/msg00418.html
+    return pSyms->pHash ? 
+	pSyms->pHash->nchain - pSyms->pGNUHash->symndx :
+	pSyms->pGNUHash->symndx;
   } else {
     return pSyms->pHash->nchain;
   }
@@ -226,12 +266,16 @@
   if(!pSyms || !pSyms->pSymTab)
     return NULL;
 
+#if defined(DC_DLOPEN_HACK)
   if (pSyms->pGNUHash) {
     export_base = pSyms->pGNUHash->symndx;
   } else {
     export_base = 0;
   }
   return (void*) pSyms->pSymTab[ export_base + index ].st_value;
+#else
+  return dlFindSymbol(pSyms->pLib, dlSymsName(pSyms, index));
+#endif
 }
 
 
Index: ~/src/dyncall/dyncall/dynload/dynload_unix.c
===================================================================
--- ~/src/dyncall/dyncall/dynload/dynload_unix.c	
+++ ~/src/dyncall/dyncall/dynload/dynload_unix.c	
@@ -27,21 +27,49 @@
 
 
 #include "dynload.h"
+#include "dynload_unix.h"
 
 #include <dlfcn.h>
+#if !defined(DC_DLOPEN_HACK)
+#  include <sys/mman.h>
+#  include <stdio.h>
+#  include <sys/stat.h>
+#  include <sys/fcntl.h>
+#endif
 
 DLLib* dlLoadLibrary(const char* libPath)
 {
-  return (DLLib*) dlopen(libPath,RTLD_NOW);
+  DLLib* pLib = (DLLib*)malloc(sizeof(DLLib));
+  pLib->libHandle = dlopen(libPath, RTLD_NOW);
+  
+#if !defined(DC_DLOPEN_HACK)
+  {  
+    struct stat st;
+    pLib->file = open(libPath, O_RDONLY);
+    stat(libPath, &st);
+    pLib->fileSize = st.st_size;
+    pLib->pElf_Ehdr = mmap(NULL, pLib->fileSize, PROT_READ, MAP_SHARED, pLib->file, 0);
+  }
+#else
+  pLib->pElf_Ehdr = pLib->libHandle;
+#endif
+
+  return pLib;
 }
 
-void* dlFindSymbol(DLLib* libHandle, const char* symbol)
+void* dlFindSymbol(DLLib* pLib, const char* symbol)
 {
-  return dlsym( (void*) libHandle, symbol);
+  return dlsym(pLib ? pLib->libHandle : RTLD_DEFAULT, symbol);
 }
 
-void  dlFreeLibrary(DLLib* libHandle)
+void  dlFreeLibrary(DLLib* pLib)
 {
-  dlclose( (void*) libHandle);
+#if !defined(DC_DLOPEN_HACK)
+  munmap(pLib->pElf_Ehdr, pLib->fileSize);
+  close(pLib->file);
+#endif
+
+  dlclose(pLib->libHandle);
+  free(pLib);
 }
 
Index: ~/src/dyncall/dyncall/buildsys/gmake/prolog.gmake
===================================================================
--- ~/src/dyncall/dyncall/buildsys/gmake/prolog.gmake	
+++ ~/src/dyncall/dyncall/buildsys/gmake/prolog.gmake	
@@ -28,6 +28,7 @@
 
 # config settings
 
+#$(if $(wildcard "${TOP}/ConfigVars"),$(error hmm),$(error File 'ConfigVars' not found at top directory. Run 'configure' - or, if you use CMake, run 'make -f Makefile' please.))
 ifeq ($(wildcard $(TOP)/ConfigVars),)
 $(error File 'ConfigVars' not found at top directory. Run 'configure' - or, if you use CMake, run 'make -f Makefile' please.)
 else
