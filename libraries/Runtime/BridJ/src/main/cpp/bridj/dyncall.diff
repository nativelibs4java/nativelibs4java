Index: dyncall/dyncallback/dyncall_args_x86.c
===================================================================
--- dyncall/dyncallback/dyncall_args_x86.c	
+++ dyncall/dyncallback/dyncall_args_x86.c	
@@ -81,6 +81,20 @@
 
 DCArgsVT dcArgsVT_default   = { default_i32, default_i64, default_f32, default_f64 };
 
+// thiscall (microsoft) calling convention :
+
+static int this_i32(DCArgs* args)
+{
+	if (args->fast_data[0]) { // ecx register = this pointer
+		int thisArg = args->fast_data[0];
+		args->fast_data[0] = 0;
+		return thisArg;
+	}
+	return *args->stack_ptr++;
+}
+
+DCArgsVT dcArgsVT_this_ms = { this_i32, default_i64, default_f32, default_f64 };
+
 // fastcall (microsoft) calling convention:
 
 static int fast_i32(DCArgs* args)
Index: dyncall/dyncallback/dyncall_callback_x86.c
===================================================================
--- dyncall/dyncallback/dyncall_callback_x86.c	
+++ dyncall/dyncallback/dyncall_callback_x86.c	
@@ -114,6 +114,39 @@
   return size;
 }
 
+static int dcbCleanupSize_x86_this_ms(const char* signature)
+{
+  const char* ptr = signature;
+  int size = 0;
+  char ch;
+  while( (ch = *ptr++) != DC_SIGCHAR_ENDARG )
+  {
+    switch(ch)
+    {
+    case DC_SIGCHAR_BOOL:
+    case DC_SIGCHAR_CHAR:
+    case DC_SIGCHAR_SHORT:
+    case DC_SIGCHAR_INT:
+    case DC_SIGCHAR_LONG:
+    case DC_SIGCHAR_POINTER:
+    case DC_SIGCHAR_UCHAR:
+    case DC_SIGCHAR_USHORT:
+    case DC_SIGCHAR_UINT:
+    case DC_SIGCHAR_ULONG:
+    case DC_SIGCHAR_STRING:
+    case DC_SIGCHAR_FLOAT:
+      size += 4;
+      break;
+    case DC_SIGCHAR_DOUBLE:
+    case DC_SIGCHAR_LONGLONG:
+    case DC_SIGCHAR_ULONGLONG:
+      size += 8;
+      break;
+    }
+  }
+  return size;
+}
+
 static int dcbCleanupSize_x86_fast_gnu(const char* signature)
 {
   const char* ptr = signature;
@@ -165,6 +198,7 @@
       case DC_SIGCHAR_CC_STDCALL:      mode = DC_CALL_C_X86_WIN32_STD;      break;
       case DC_SIGCHAR_CC_FASTCALL_GNU: mode = DC_CALL_C_X86_WIN32_FAST_GNU; break;
       case DC_SIGCHAR_CC_FASTCALL_MS:  mode = DC_CALL_C_X86_WIN32_FAST_MS;  break;
+      case DC_SIGCHAR_CC_THISCALL_MS:  mode = DC_CALL_C_X86_WIN32_THIS_MS;  break;
     }
   }
 
@@ -183,6 +217,10 @@
     pcb->args_vt = &dcArgsVT_fast_ms;
     pcb->stack_cleanup = dcbCleanupSize_x86_fast_ms(ptr);
     break;
+  case DC_CALL_C_X86_WIN32_THIS_MS:
+    pcb->args_vt = &dcArgsVT_this_ms;
+    pcb->stack_cleanup = dcbCleanupSize_x86_this_ms(ptr);
+    break;
   case DC_CALL_C_X86_WIN32_FAST_GNU:
     pcb->args_vt = &dcArgsVT_fast_gnu;
     pcb->stack_cleanup = dcbCleanupSize_x86_fast_gnu(ptr);
Index: dyncall/dyncallback/dyncall_args_x86.h
===================================================================
--- dyncall/dyncallback/dyncall_args_x86.h	
+++ dyncall/dyncallback/dyncall_args_x86.h	
@@ -36,6 +36,7 @@
 
 extern DCArgsVT dcArgsVT_default;
 extern DCArgsVT dcArgsVT_fast_ms;
+extern DCArgsVT dcArgsVT_this_ms;
 extern DCArgsVT dcArgsVT_fast_gnu;
 
 struct DCArgs
Index: dyncall/dyncallback/dyncall_callback_x86_gas.S
===================================================================
--- dyncall/dyncallback/dyncall_callback_x86_gas.S	
+++ dyncall/dyncallback/dyncall_callback_x86_gas.S	
@@ -95,21 +95,25 @@
 
 	// handle return value
 
+	cmp %al, 'v'
+	je .return_void
 	cmp %al, 'd'
 	je .return_f64
 	cmp %al, 'f'
 	je .return_f32
 	cmp %al, 'l'
 	je .return_i64
-	cmp %al, 'i'
-	je .return_i32
-	ret
+	cmp %al, 'L'
+	je .return_i64_
+	
+	// All int cases <= 32 bits (+ pointer & string cases) fall in the 32 bits int case
 
 .return_i32:
 	mov  %eax, [%edx]
 	ret
 
 .return_i64:
+.return_i64_:
 	mov  %eax, [%edx]
 	mov  %edx, [%edx+4]
 	ret
@@ -121,3 +125,6 @@
 .return_f64:
 	fld qword ptr [%edx]
 	ret
+
+.return_void:
+  	ret
Index: dyncall/dyncallback/dyncall_callback_x86_masm.asm
===================================================================
--- dyncall/dyncallback/dyncall_callback_x86_masm.asm	
+++ dyncall/dyncallback/dyncall_callback_x86_masm.asm	
@@ -93,16 +93,19 @@
   mov  ebp, [ebp]                    ; EBP = parent frame
 
   ; handle return value
+  
+  cmp al, 'v'
+  je return_void
   cmp al, 'd'
   je return_f64
   cmp al, 'f'
   je return_f32
   cmp al, 'l'
   je return_i64
-  cmp al, 'i'
-  je return_i32
-  ret
-
+  cmp al, 'L'
+  je return_i64
+  ; All int cases <= 32 bits (+ pointer & string cases) fall in the 32 bits int case
+  
 return_i32:
   mov  eax, [edx]
   ret
@@ -120,6 +123,9 @@
   fld qword ptr [edx]
   ret
 
+return_void:
+  ret
+
 _dcCallbackThunkEntry ENDP
 
 END
Index: dyncall/dyncallback/dyncall_callback_x86_apple.s
===================================================================
--- dyncall/dyncallback/dyncall_callback_x86_apple.s	
+++ dyncall/dyncallback/dyncall_callback_x86_apple.s	
@@ -44,10 +44,12 @@
 frame_DCArgs       = -24
 frame_DCValue      = -32
 
+ASCII_L = 76
 ASCII_l = 108
 ASCII_d	= 100
 ASCII_f = 102
 ASCII_i = 105
+ASCII_v = 118
 
 _dcCallbackThunkEntry:
 	push %ebp
@@ -96,21 +98,25 @@
 
 	// handle return value
 
+	cmp %al, ASCII_v
+	je .return_void
 	cmp %al, ASCII_d
 	je .return_f64
 	cmp %al, ASCII_f
 	je .return_f32
 	cmp %al, ASCII_l
 	je .return_i64
-	cmp %al, ASCII_i
-	je .return_i32
-	ret
+	cmp %al, ASCII_L
+	je .return_i64_
+	
+	// All int cases <= 32 bits (+ pointer & string cases) fall in the 32 bits int case	
 
 .return_i32:
 	mov  %eax, [%edx]
 	ret
 
 .return_i64:
+.return_i64_:
 	mov  %eax, [%edx]
 	mov  %edx, [%edx+4]
 	ret
@@ -122,3 +128,6 @@
 .return_f64:
 	fld qword ptr [%edx]
 	ret
+
+.return_void:
+	ret
Index: dyncall/test/plain/test_main.c
===================================================================
--- dyncall/test/plain/test_main.c	
+++ dyncall/test/plain/test_main.c	
@@ -284,6 +284,7 @@
 DC_DEFINE_TEST_FUNC_END
 #endif
 
+int testCallStructs();
 
 int main(int argc, char* argv[])
 {
@@ -293,6 +294,12 @@
   b = b && testCallC();
   printf("C:%d\n",b);
 
+  b = b && testStructSizes();
+  printf("Struct Sizes:%d\n",b);
+
+  b = b && testCallStructs();
+  printf("Call Structs:%d\n",b);
+
 #if defined(DC__OS_Win32)
   
   b = b && testCallStd();
Index: dyncall/test/plain/GNUmakefile
===================================================================
--- dyncall/test/plain/GNUmakefile	
+++ dyncall/test/plain/GNUmakefile	
@@ -24,7 +24,7 @@
 include $(GMAKE_TOP)/prolog.gmake
 
 TARGET_APP	= plain
-UNITS		= test_main
+UNITS		= test_main test_structs
 CPPFLAGS	+= -I$(TOP)/dyncall
 LINK_DIRS	= $(TOP)/dyncall/$(BUILD_DIR)
 LINK_LIBS       = dyncall_s
Index: dyncall/test/plain/test_structs.c
===================================================================
--- dyncall/test/plain/test_structs.c	
+++ dyncall/test/plain/test_structs.c	
@@ -0,0 +1,212 @@
+/*
+
+ Copyright (c) 2010-2011 Olivier Chafik <olivier.chafik@gmail.com>
+
+ Permission to use, copy, modify, and distribute this software for any
+ purpose with or without fee is hereby granted, provided that the above
+ copyright notice and this permission notice appear in all copies.
+
+ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+*/
+
+
+//#include "../common/platformInit.h"
+#include "test_framework.h"
+#include "../../dyncall/dyncall.h"
+#include "../../dyncall/dyncall_signature.h"
+#include "../../dyncall/dyncall_struct.h"
+#include <stdio.h>
+
+#define DC_TEST_INT_EQUAL(expected, computed) { \
+	if (expected != computed) \
+		printf("expected = %d, computed = %d\n\n", (int)expected, (int)computed); \
+  	DC_TEST(expected == computed); \
+}
+#define DC_TEST_STRUCT_SIZE(type, s) { \
+	DCsize expected = sizeof(type), computed = dcStructSize(s);\
+	DC_TEST_INT_EQUAL(expected, computed); \
+}
+
+DC_DEFINE_TEST_FUNC_BEGIN(testStructSizes)
+
+  {
+  	typedef struct _S {
+  	  double a, b, c, d;  
+  	} S;
+  	
+  	size_t size;
+  	DCstruct* s = dcNewStruct(4, DEFAULT_ALIGNMENT);
+  	dcStructField(s, DC_SIGCHAR_DOUBLE, DEFAULT_ALIGNMENT, 1);
+  	dcStructField(s, DC_SIGCHAR_DOUBLE, DEFAULT_ALIGNMENT, 1);
+  	dcStructField(s, DC_SIGCHAR_DOUBLE, DEFAULT_ALIGNMENT, 1);
+  	dcStructField(s, DC_SIGCHAR_DOUBLE, DEFAULT_ALIGNMENT, 1);
+  	dcCloseStruct(s);
+  	
+  	DC_TEST_STRUCT_SIZE(S, s);
+  	dcFreeStruct(s);
+  }
+  {
+  	typedef struct _S {
+  	  char a, b;
+  	  void* p[3];
+  	} S;
+  	
+  	size_t size;
+  	DCstruct* s = dcNewStruct(3, DEFAULT_ALIGNMENT);
+  	dcStructField(s, DC_SIGCHAR_CHAR, DEFAULT_ALIGNMENT, 1);
+  	dcStructField(s, DC_SIGCHAR_CHAR, DEFAULT_ALIGNMENT, 1);
+  	dcStructField(s, DC_SIGCHAR_POINTER, DEFAULT_ALIGNMENT, 3);
+  	dcCloseStruct(s);
+  	
+  	DC_TEST_STRUCT_SIZE(S, s);
+  	dcFreeStruct(s);
+  }
+  {
+  	typedef struct _S {
+  	  short a;
+  	  struct {
+  	    char a, b;
+  	    void* p[3];
+  	  } sub;
+  	  short b;
+  	} S;
+  	
+  	size_t size;
+  	DCstruct* s = dcNewStruct(3, DEFAULT_ALIGNMENT);
+  	dcStructField(s, DC_SIGCHAR_SHORT, DEFAULT_ALIGNMENT, 1);
+  	dcSubStruct(s, 3, DEFAULT_ALIGNMENT, 1); 
+		dcStructField(s, DC_SIGCHAR_CHAR, DEFAULT_ALIGNMENT, 1);
+		dcStructField(s, DC_SIGCHAR_CHAR, DEFAULT_ALIGNMENT, 1);
+		dcStructField(s, DC_SIGCHAR_POINTER, DEFAULT_ALIGNMENT, 3);
+	dcCloseStruct(s);
+	dcStructField(s, DC_SIGCHAR_SHORT, DEFAULT_ALIGNMENT, 1);
+  	dcCloseStruct(s);
+  	
+  	DC_TEST_STRUCT_SIZE(S, s);
+  	dcFreeStruct(s);
+  }
+  
+#define TEST_MONO_STRUCT(type, sig) \
+  { \
+  	typedef struct _S { \
+  	  type v;  \
+  	} S; \
+  	 \
+  	DCstruct* s = dcNewStruct(1, DEFAULT_ALIGNMENT); \
+  	dcStructField(s, sig, DEFAULT_ALIGNMENT, 1); \
+  	dcCloseStruct(s); \
+  	 \
+  	DC_TEST_STRUCT_SIZE(S, s); \
+  	dcFreeStruct(s); \
+  }
+  
+  TEST_MONO_STRUCT(char, DC_SIGCHAR_CHAR);
+  TEST_MONO_STRUCT(unsigned char, DC_SIGCHAR_UCHAR);
+  TEST_MONO_STRUCT(short, DC_SIGCHAR_SHORT);
+  TEST_MONO_STRUCT(unsigned short, DC_SIGCHAR_USHORT);
+  TEST_MONO_STRUCT(int, DC_SIGCHAR_INT);
+  TEST_MONO_STRUCT(unsigned int, DC_SIGCHAR_UINT);
+  TEST_MONO_STRUCT(long, DC_SIGCHAR_LONG);
+  TEST_MONO_STRUCT(unsigned long, DC_SIGCHAR_ULONG);
+  TEST_MONO_STRUCT(long long, DC_SIGCHAR_LONGLONG);
+  TEST_MONO_STRUCT(unsigned long long, DC_SIGCHAR_ULONGLONG);
+  TEST_MONO_STRUCT(void*, DC_SIGCHAR_POINTER);
+  TEST_MONO_STRUCT(float, DC_SIGCHAR_FLOAT);
+  TEST_MONO_STRUCT(double, DC_SIGCHAR_DOUBLE); 
+  
+DC_DEFINE_TEST_FUNC_END
+
+
+typedef struct {
+  char a, b;
+  double p[10];
+} SomeValues;
+
+DCstruct* describe_SomeValues() {
+	DCstruct* s = dcNewStruct(3, DEFAULT_ALIGNMENT);
+  	dcStructField(s, DC_SIGCHAR_CHAR, DEFAULT_ALIGNMENT, 1);
+  	dcStructField(s, DC_SIGCHAR_CHAR, DEFAULT_ALIGNMENT, 1);
+  	dcStructField(s, DC_SIGCHAR_DOUBLE, DEFAULT_ALIGNMENT, 10);
+  	dcCloseStruct(s);
+  	return s;
+}
+double sum_SomeValues(SomeValues* values) {
+	return ((double)values->a) + ((double)values->b) + values->p[0] + values->p[1] + values->p[2];
+}
+
+typedef struct {
+  char a, b, c;
+} FewValues;
+
+DCstruct* describe_FewValues() {
+	DCstruct* s = dcNewStruct(3, DEFAULT_ALIGNMENT);
+  	dcStructField(s, DC_SIGCHAR_CHAR, DEFAULT_ALIGNMENT, 1);
+  	dcStructField(s, DC_SIGCHAR_CHAR, DEFAULT_ALIGNMENT, 1);
+  	dcStructField(s, DC_SIGCHAR_CHAR, DEFAULT_ALIGNMENT, 1);
+  	dcCloseStruct(s);
+  	return s;
+}
+double sum_FewValues(FewValues* values) {
+	printf("sum_FewValues(a = %d, b = %d, c = %d)\n", (int)values->a, (int)values->b, (int)values->c); 
+	return ((double)values->a) + ((double)values->b) + ((double)values->c);
+}
+
+DC_DEFINE_TEST_FUNC_BEGIN(testCallStructs)
+
+  DCCallVM* pc = dcNewCallVM(4096);
+  {
+  	FewValues values;
+  	double calledSum, expectedSum;
+  	DCstruct* s = describe_FewValues();
+  	
+  	DC_TEST_STRUCT_SIZE(FewValues, s);
+  	
+  	values.a = 1;
+	values.b = 2;
+	values.c = 3;
+	
+    dcReset(pc);
+    dcMode(pc, DC_CALL_C_DEFAULT);
+    printf("BEFORE dcArgStruct\n");
+	dcArgStruct(pc, s, &values);
+    printf("AFTER dcArgStruct\n");
+    calledSum = dcCallDouble(pc, (DCpointer) &sum_FewValues);
+    expectedSum = sum_FewValues(&values);
+    
+	DC_TEST_INT_EQUAL(expectedSum, calledSum);
+  	dcFreeStruct(s);
+  }
+  {
+  	SomeValues values;
+  	double calledSum, expectedSum;
+  	DCstruct* s = describe_SomeValues();
+  	
+  	DC_TEST_STRUCT_SIZE(SomeValues, s);
+  	
+  	values.a = 1;
+	values.b = 2;
+	values.p[0] = 10;
+	values.p[1] = 11;
+	values.p[2] = 12;
+	
+    dcReset(pc);
+    dcMode(pc, DC_CALL_C_DEFAULT);
+	dcArgStruct(pc, s, &values);
+    calledSum = dcCallDouble(pc, (DCpointer) &sum_SomeValues);
+    expectedSum = sum_SomeValues(&values);
+    
+	DC_TEST_INT_EQUAL(expectedSum, calledSum);
+  	dcFreeStruct(s);
+  }
+  
+  dcFree(pc);
+
+DC_DEFINE_TEST_FUNC_END
+
Index: dyncall/dyncall/dyncall_callvm_mips_n64.c
===================================================================
--- dyncall/dyncall/dyncall_callvm_mips_n64.c	
+++ dyncall/dyncall/dyncall_callvm_mips_n64.c	
@@ -190,6 +190,7 @@
 , &dc_callvm_argFloat_mips_n64
 , &dc_callvm_argDouble_mips_n64
 , &dc_callvm_argPointer_mips_n64
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_mips_n64
 , (DCboolvmfunc*)       &dc_callvm_call_mips_n64
 , (DCcharvmfunc*)       &dc_callvm_call_mips_n64
@@ -200,6 +201,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_mips_n64
 , (DCdoublevmfunc*)     &dc_callvm_call_mips_n64
 , (DCpointervmfunc*)    &dc_callvm_call_mips_n64
+, NULL // argStruct
 };
 
 DCCallVM_vt gVT_mips_n64_ellipsis =
Index: dyncall/dyncall/dyncall_vector.c
===================================================================
--- dyncall/dyncall/dyncall_vector.c	
+++ dyncall/dyncall/dyncall_vector.c	
@@ -22,14 +22,31 @@
 
 #include "dyncall_vector.h"
 #include <string.h>
+//void memcpy(void*, const void*, size_t);
 
 void dcVecAppend(DCVecHead* pHead, const void* pData, size_t size)
 {
-  if (pHead->mSize+size <= pHead->mTotal) 
+	size_t newSize = pHead->mSize + size;
+  if (newSize <= pHead->mTotal) 
   {
-    void* dst = (char*)dcVecData(pHead) + pHead->mSize;
-    memcpy(dst, pData, size); /* @@@ heavy for small types. */
-    pHead->mSize += size;
+  	void* dst = (char*)dcVecData(pHead) + pHead->mSize;
+  	switch (size) {
+  	case 1:
+  		*(char*)dst = *(const char*)pData;
+  		break;
+  	case 2:
+  		*(short*)dst = *(const short*)pData;
+  		break;
+  	case 4:
+  		*(int*)dst = *(const int*)pData;
+  		break;
+  	case 8:
+  		*(long long*)dst = *(const long long*)pData;
+  		break;
+  	default:
+  		memcpy(dst, pData, size); /* @@@ heavy for small types. */
+  	}
+    pHead->mSize = newSize;
   } 
 }
 
Index: dyncall/dyncall/dyncall_struct.c
===================================================================
--- dyncall/dyncall/dyncall_struct.c	
+++ dyncall/dyncall/dyncall_struct.c	
@@ -0,0 +1,222 @@
+/*
+ Package: dyncall
+ File: dyncall/dyncall_struct.c
+ Description: C interface to compute struct size
+ License:
+ Copyright (c) 2010 Olivier Chafik <olivier.chafik@centraliens.net>
+
+ Permission to use, copy, modify, and distribute this software for any
+ purpose with or without fee is hereby granted, provided that the above
+ copyright notice and this permission notice appear in all copies.
+
+ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+*/
+
+#include "dyncall.h"
+#include "dyncall_signature.h"
+#include "dyncall_struct.h"
+#include "dyncall_alloc.h"
+#include <stdio.h>
+#include <assert.h>
+
+#define ASSERT(x) assert(x)
+
+DCstruct*  dcNewStruct(DCsize fieldCount, DCint alignment) {
+	DCstruct* s = (DCstruct*)dcAllocMem(sizeof(DCstruct));
+	s->pCurrentStruct = s;
+	s->pLastStruct = NULL;
+	s->nextField = 0;
+	s->fieldCount = fieldCount;
+	s->alignment = alignment;
+	s->size = 0;
+	s->pFields = (DCfield*)dcAllocMem(fieldCount * sizeof(DCfield));
+	return s;
+}
+void dcStructField(DCstruct* s, DCint type, DCint alignment, DCsize arrayLength) {
+	DCfield *f;
+	if (type == DC_SIGCHAR_STRING) {
+		ASSERT(!"Use dcSubStruct instead !!!");
+		return;
+	}
+	ASSERT(s && s->pCurrentStruct);
+	ASSERT(s->pCurrentStruct->nextField <= (DCint)s->pCurrentStruct->fieldCount - 1);
+	f = s->pCurrentStruct->pFields + (s->pCurrentStruct->nextField++);
+	f->type = type;
+	f->alignment = alignment;
+	f->arrayLength = arrayLength;
+	f->pSubStruct = NULL;
+	switch (type) {
+    case DC_SIGCHAR_BOOL:       f->size = sizeof(DCbool); break;
+    case DC_SIGCHAR_CHAR:       
+    case DC_SIGCHAR_UCHAR:      f->size = sizeof(DCchar); break;
+    case DC_SIGCHAR_SHORT:      
+    case DC_SIGCHAR_USHORT:     f->size = sizeof(DCshort); break;
+    case DC_SIGCHAR_INT:        
+    case DC_SIGCHAR_UINT:       f->size = sizeof(DCint); break;
+    case DC_SIGCHAR_LONG:       
+    case DC_SIGCHAR_ULONG:      f->size = sizeof(DClong); break;
+    case DC_SIGCHAR_LONGLONG:   
+    case DC_SIGCHAR_ULONGLONG:  f->size = sizeof(DClonglong); break;
+    case DC_SIGCHAR_FLOAT:      f->size = sizeof(DCfloat); break;
+    case DC_SIGCHAR_DOUBLE:     f->size = sizeof(DCdouble); break;
+    case DC_SIGCHAR_POINTER:
+	case DC_SIGCHAR_STRING:     f->size = sizeof(DCpointer); break;
+	default:                    ASSERT(0);
+	}
+}
+void dcSubStruct(DCstruct* s, DCsize fieldCount, DCint alignment, DCsize arrayLength) {
+	DCfield *f = s->pCurrentStruct->pFields + (s->pCurrentStruct->nextField++);
+	f->type = DC_SIGCHAR_STRUCT;
+	f->arrayLength = arrayLength;
+	f->alignment = alignment;
+	f->pSubStruct = dcNewStruct(fieldCount, alignment);
+	f->pSubStruct->pLastStruct = s->pCurrentStruct;
+	s->pCurrentStruct = f->pSubStruct;
+}  	
+void dcAlign(DCsize *size, DCsize alignment) {
+	DCsize mod = (*size) % alignment;
+	if (mod) {
+		DCsize rest = alignment - mod;
+		(*size) += rest;
+	}
+}
+void dcComputeStructSize(DCstruct* s) {
+	DCsize i;
+	ASSERT(s);
+	for (i = 0; i < s->fieldCount; i++) {
+		DCfield *f = s->pFields + i;
+		DCsize fieldAlignment;
+		if (f->type == DC_SIGCHAR_STRUCT) {
+			dcComputeStructSize(f->pSubStruct);
+			f->size = f->pSubStruct->size;
+			fieldAlignment = f->pSubStruct->alignment;
+		} else {
+			fieldAlignment = f->size;
+		}
+		if (!f->alignment)
+			f->alignment = fieldAlignment;
+		
+		if (f->alignment > s->alignment)
+			s->alignment = f->alignment;
+		
+		f->size *= f->arrayLength;
+		
+		//printf("FIELD %d, size = %d, alignment = %d\n", (int)i, (int)f->size, (int)f->alignment);
+	}
+	for (i = 0; i < s->fieldCount; i++) {
+		DCfield *f = s->pFields + i;
+		dcAlign(&s->size, f->alignment);
+		s->size += f->size;
+	}
+	dcAlign(&s->size, s->alignment);
+	
+	//printf("STRUCT size = %d, alignment = %d\n", (int)s->size, (int)s->alignment);
+}
+
+// Each dcNewStruct or dcSubStruct call must be paired with a dcCloseStruct
+void dcCloseStruct(DCstruct* s) {
+	ASSERT(s);
+	ASSERT(s->pCurrentStruct);
+	ASSERT(s->pCurrentStruct->nextField == s->pCurrentStruct->fieldCount);
+	if (!s->pCurrentStruct->pLastStruct) {
+		dcComputeStructSize(s->pCurrentStruct);
+	}
+	s->pCurrentStruct = s->pCurrentStruct->pLastStruct;
+}
+
+void dcFreeStruct(DCstruct* s) {
+	DCsize i;
+	ASSERT(s);
+	for (i = 0; i < s->fieldCount; i++) {
+		DCfield *f = s->pFields + i;
+		if (f->type == DC_SIGCHAR_STRUCT)
+			dcFreeStruct(f->pSubStruct);
+	}
+	free(s->pFields);
+	free(s);
+}
+DCsize dcStructSize(DCstruct* s) {
+	ASSERT(!s->pCurrentStruct && "Struct was not closed");
+	return s->size;
+}
+void dcArgStructUnroll(DCCallVM* vm, DCstruct* s, DCpointer  value) {
+	DCsize i;
+	//printf("UNROLLING STRUCT !\n");
+	ASSERT(s && value);
+	for (i = 0; i < s->fieldCount; i++) {
+		DCfield *f = s->pFields + i;
+		DCpointer p = (char*)value + f->offset;
+		switch(f->type) {
+		  case DC_SIGCHAR_STRUCT:
+		  	dcArgStruct(vm, f->pSubStruct, p);
+		  	break;
+		  case DC_SIGCHAR_BOOL: 
+			dcArgBool      (vm, *(DCbool*)p); 
+			break;
+		  case DC_SIGCHAR_CHAR:
+		  case DC_SIGCHAR_UCHAR:
+			dcArgChar      (vm, *(DCchar*)p);
+			break;
+		  case DC_SIGCHAR_SHORT:
+		  case DC_SIGCHAR_USHORT:
+			dcArgShort     (vm, *(DCshort*)p);
+			break;
+		  case DC_SIGCHAR_INT:
+		  case DC_SIGCHAR_UINT:
+			dcArgInt       (vm, *(DCint*)p);
+			break;
+		  case DC_SIGCHAR_LONG:
+		  case DC_SIGCHAR_ULONG:
+			dcArgLong      (vm, *(DCulong*)p);
+			break;
+		  case DC_SIGCHAR_LONGLONG:
+		  case DC_SIGCHAR_ULONGLONG:
+			dcArgLongLong  (vm, *(DCulonglong*)p);
+			break;
+		  case DC_SIGCHAR_FLOAT:
+			dcArgFloat     (vm, *(DCfloat*)p);
+			break;
+		  case DC_SIGCHAR_DOUBLE:
+			dcArgDouble    (vm, *(DCdouble*)p);
+			break;
+		  case DC_SIGCHAR_POINTER:
+		  case DC_SIGCHAR_STRING:
+			dcArgPointer   (vm, *(DCpointer**)p);
+			break;
+	       default:
+	       	ASSERT(0);
+		}	
+	}
+}
+
+DCbool isDigit(char c) {
+	return c >= '0' && c <= '9';
+}
+DCint readInt(const char** ptr) {
+	return strtol(*ptr, (char**)ptr, 10);
+}
+
+DCstruct*  dcDefineStruct(const char* signature) {
+	DCstruct* s;
+	const char* ptr = signature;
+	DCint fieldCount = readInt(&ptr);
+	s = dcNewStruct(fieldCount, DEFAULT_ALIGNMENT);
+	
+	while (*ptr) {
+		char type = *(ptr++);
+		if (type == DC_SIGCHAR_STRUCT) {
+			//dcSubStruct(	
+		} else {
+			dcStructField(s, type, DEFAULT_ALIGNMENT, readInt(&ptr));
+		}
+	}
+	dcCloseStruct(s);
+	return s;
+}
Index: dyncall/dyncall/dyncall_callvm_mips_eabi.c
===================================================================
--- dyncall/dyncall/dyncall_callvm_mips_eabi.c	
+++ dyncall/dyncall/dyncall_callvm_mips_eabi.c	
@@ -152,6 +152,7 @@
 , &dc_callvm_argFloat_mips_eabi
 , &dc_callvm_argDouble_mips_eabi
 , &dc_callvm_argPointer_mips_eabi
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_mips_eabi
 , (DCboolvmfunc*)       &dc_callvm_call_mips_eabi
 , (DCcharvmfunc*)       &dc_callvm_call_mips_eabi
@@ -162,6 +163,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_mips_eabi
 , (DCdoublevmfunc*)     &dc_callvm_call_mips_eabi
 , (DCpointervmfunc*)    &dc_callvm_call_mips_eabi
+, NULL // argStruct
 };
 
 DCCallVM* dcNewCallVM_mips_eabi(DCsize size) 
Index: dyncall/dyncall/dyncall_struct.h
===================================================================
--- dyncall/dyncall/dyncall_struct.h	
+++ dyncall/dyncall/dyncall_struct.h	
@@ -0,0 +1,64 @@
+/*
+ Package: dyncall
+ File: dyncall/dyncall_struct.h
+ Description: C interface to compute struct size
+ License:
+ Copyright (c) 2010 Olivier Chafik <olivier.chafik@centraliens.net>
+
+ Permission to use, copy, modify, and distribute this software for any
+ purpose with or without fee is hereby granted, provided that the above
+ copyright notice and this permission notice appear in all copies.
+
+ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+*/
+
+/*
+
+  dyncall struct metadata structures
+
+  REVISION
+  2007/12/11 initial
+  
+*/
+
+#ifndef DYNCALL_STRUCT_H
+#define DYNCALL_STRUCT_H
+
+#include "dyncall.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif 
+
+#ifndef DC_API
+#define DC_API
+#endif
+
+typedef struct DCfield_ {
+	DCsize offset, size, alignment, arrayLength;
+	DCint type;
+	DCstruct* pSubStruct;
+} DCfield;
+
+struct DCstruct_ {
+	DCfield *pFields;
+	DCsize size, alignment, fieldCount;
+	
+	// struct building uses a state machine :
+	DCint nextField;       // == -1 if struct is closed
+	DCstruct *pCurrentStruct, *pLastStruct; // == this, unless we're in a sub struct
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* DYNCALL_H */
+
Index: dyncall/dyncall/GNUmakefile
===================================================================
--- dyncall/dyncall/GNUmakefile	
+++ dyncall/dyncall/GNUmakefile	
@@ -38,6 +38,7 @@
 INSTALL_LIB = 1
 
 UNITS = dyncall_vector dyncall_api dyncall_callvm dyncall_callvm_base
+UNITS += dyncall_struct
 
 # @@@ disable dyncall_callf for pcc support temporarly
 ifndef BUILD_TOOL_pcc
Index: dyncall/dyncall/dyncall_api.c
===================================================================
--- dyncall/dyncall/dyncall_api.c	
+++ dyncall/dyncall/dyncall_api.c	
@@ -85,6 +85,13 @@
   vm->mVTpointer->argPointer(vm,x); 
 }
 
+void dcArgStruct(DCCallVM* vm, DCstruct* s, DCpointer x) 
+{ 
+//	printf("vm->mVTpointer->argStruct = %p\n", vm->mVTpointer->argStruct);
+  vm->mVTpointer->argStruct(vm, s, x); 
+}
+
+
 void dcCallVoid(DCCallVM* vm, DCpointer funcptr) 
 {        
   vm->mVTpointer->callVoid(vm, funcptr); 
@@ -135,6 +142,11 @@
   return vm->mVTpointer->callPointer(vm, funcptr); 
 }
 
+void dcCallStruct(DCCallVM* vm, DCpointer funcptr, DCstruct* s, DCpointer x) 
+{ 
+  vm->mVTpointer->callStruct(vm, funcptr, s, x); 
+}
+
 DCint dcGetError(DCCallVM *vm)
 {
   return vm->mError;
Index: dyncall/dyncall/dyncall_callvm_x64.c
===================================================================
--- dyncall/dyncall/dyncall_callvm_x64.c	
+++ dyncall/dyncall/dyncall_callvm_x64.c	
@@ -23,8 +23,8 @@
 
 #include "dyncall_callvm_x64.h"
 #include "dyncall_alloc.h"
+#include "dyncall_struct.h"
 
-
 static DCCallVM* dc_callvm_new_x64(DCCallVM_vt* vt, DCsize size)
 {
   DCCallVM_x64* self = (DCCallVM_x64*)dcAllocMem(sizeof(DCCallVM_x64)+size);
@@ -148,7 +148,18 @@
     dcVecAppend(&self->mVecHead, &x, sizeof(DCpointer));
 }
 
+static void dc_callvm_argStruct_x64(DCCallVM* in_self, DCstruct* s, DCpointer x)
+{
+  DCCallVM_x64* self = (DCCallVM_x64*)in_self;
+  dcVecAppend(&self->mVecHead, x, s->size);
+  //printf("dc_callvm_argStruct_x64 size = %d\n", (int)s->size);
+  if (s->size <= 64)
+  	  dcArgStructUnroll(in_self, s, x);
+  //else
+  //	  dcVecAppend(&self->mVecHead, &x, sizeof(DCpointer));
+}
 
+
 /* Call. */
 void dc_callvm_call_x64(DCCallVM* in_self, DCpointer target)
 {
@@ -183,6 +194,7 @@
 , &dc_callvm_argFloat_x64
 , &dc_callvm_argDouble_x64
 , &dc_callvm_argPointer_x64
+, &dc_callvm_argStruct_x64
 , (DCvoidvmfunc*)       &dc_callvm_call_x64
 , (DCboolvmfunc*)       &dc_callvm_call_x64
 , (DCcharvmfunc*)       &dc_callvm_call_x64
@@ -193,6 +205,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x64
 , (DCdoublevmfunc*)     &dc_callvm_call_x64
 , (DCpointervmfunc*)    &dc_callvm_call_x64
+, NULL // argStruct
 };
 
 
Index: dyncall/dyncall/dyncall_callvm_arm32_arm.c
===================================================================
--- dyncall/dyncall/dyncall_callvm_arm32_arm.c	
+++ dyncall/dyncall/dyncall_callvm_arm32_arm.c	
@@ -163,6 +163,7 @@
 , &dc_callvm_argFloat_arm32_arm
 , &dc_callvm_argDouble_arm32_arm
 , &dc_callvm_argPointer_arm32_arm
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_arm32_arm
 , (DCboolvmfunc*)       &dc_callvm_call_arm32_arm
 , (DCcharvmfunc*)       &dc_callvm_call_arm32_arm
@@ -173,6 +174,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_arm32_arm
 , (DCdoublevmfunc*)     &dc_callvm_call_arm32_arm
 , (DCpointervmfunc*)    &dc_callvm_call_arm32_arm
+, NULL // callStruct
 };
 
 
@@ -190,6 +192,7 @@
 , &dc_callvm_argFloat_arm32_arm
 , &dc_callvm_argDouble_arm32_arm_eabi
 , &dc_callvm_argPointer_arm32_arm
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_arm32_arm
 , (DCboolvmfunc*)       &dc_callvm_call_arm32_arm
 , (DCcharvmfunc*)       &dc_callvm_call_arm32_arm
@@ -200,6 +203,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_arm32_arm
 , (DCdoublevmfunc*)     &dc_callvm_call_arm32_arm
 , (DCpointervmfunc*)    &dc_callvm_call_arm32_arm
+, NULL // argStruct
 };
 
 
Index: dyncall/dyncall/dyncall_callvm.h
===================================================================
--- dyncall/dyncall/dyncall_callvm.h	
+++ dyncall/dyncall/dyncall_callvm.h	
@@ -49,6 +49,7 @@
   void         (*argFloat)       (DCCallVM* vm,DCfloat         f);
   void         (*argDouble)      (DCCallVM* vm,DCdouble        d);
   void         (*argPointer)     (DCCallVM* vm,DCpointer       p);
+  void         (*argStruct)      (DCCallVM* vm,DCstruct* s, DCpointer p);
   void         (*callVoid)       (DCCallVM* vm,DCpointer funcptr);
   DCbool       (*callBool)       (DCCallVM* vm,DCpointer funcptr);
   DCchar       (*callChar)       (DCCallVM* vm,DCpointer funcptr);
@@ -59,6 +60,7 @@
   DCfloat      (*callFloat)      (DCCallVM* vm,DCpointer funcptr);
   DCdouble     (*callDouble)     (DCCallVM* vm,DCpointer funcptr);
   DCpointer    (*callPointer)    (DCCallVM* vm,DCpointer funcptr);
+  void         (*callStruct)     (DCCallVM* vm,DCpointer funcptr,DCstruct* s, DCpointer returnValue);
 };
 
 typedef DCvoid       (DCvoidvmfunc)      (DCCallVM* vm,DCpointer funcptr); 
Index: dyncall/dyncall/dyncall_callvm_ppc32.c
===================================================================
--- dyncall/dyncall/dyncall_callvm_ppc32.c	
+++ dyncall/dyncall/dyncall_callvm_ppc32.c	
@@ -302,6 +302,7 @@
 , &dc_callvm_argFloat_ppc32_darwin
 , &dc_callvm_argDouble_ppc32_darwin
 , &dc_callvm_argPointer_ppc32
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_ppc32_darwin
 , (DCboolvmfunc*)       &dc_callvm_call_ppc32_darwin
 , (DCcharvmfunc*)       &dc_callvm_call_ppc32_darwin
@@ -312,6 +313,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_ppc32_darwin
 , (DCdoublevmfunc*)     &dc_callvm_call_ppc32_darwin
 , (DCpointervmfunc*)    &dc_callvm_call_ppc32_darwin
+, NULL // argStruct
 };
 
 DCCallVM_vt gVT_ppc32_sysv =
@@ -328,6 +330,7 @@
 , &dc_callvm_argFloat_ppc32_sysv
 , &dc_callvm_argDouble_ppc32_sysv
 , &dc_callvm_argPointer_ppc32
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_ppc32_sysv
 , (DCboolvmfunc*)       &dc_callvm_call_ppc32_sysv
 , (DCcharvmfunc*)       &dc_callvm_call_ppc32_sysv
@@ -338,6 +341,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_ppc32_sysv
 , (DCdoublevmfunc*)     &dc_callvm_call_ppc32_sysv
 , (DCpointervmfunc*)    &dc_callvm_call_ppc32_sysv
+, NULL // argStruct
 };
 
 void dc_callvm_mode_ppc32(DCCallVM* in_self, DCint mode)
Index: dyncall/dyncall/dyncall_callvm_mips_n32.c
===================================================================
--- dyncall/dyncall/dyncall_callvm_mips_n32.c	
+++ dyncall/dyncall/dyncall_callvm_mips_n32.c	
@@ -190,6 +190,7 @@
 , &dc_callvm_argFloat_mips_n32
 , &dc_callvm_argDouble_mips_n32
 , &dc_callvm_argPointer_mips_n32
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_mips_n32
 , (DCboolvmfunc*)       &dc_callvm_call_mips_n32
 , (DCcharvmfunc*)       &dc_callvm_call_mips_n32
@@ -200,6 +201,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_mips_n32
 , (DCdoublevmfunc*)     &dc_callvm_call_mips_n32
 , (DCpointervmfunc*)    &dc_callvm_call_mips_n32
+, NULL // argStruct
 };
 
 DCCallVM_vt gVT_mips_n32_ellipsis =
@@ -216,6 +218,7 @@
 , &dc_callvm_argFloat_mips_n32_ellipsis
 , &dc_callvm_argDouble_mips_n32_ellipsis
 , &dc_callvm_argPointer_mips_n32
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_mips_n32
 , (DCboolvmfunc*)       &dc_callvm_call_mips_n32
 , (DCcharvmfunc*)       &dc_callvm_call_mips_n32
@@ -226,6 +229,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_mips_n32
 , (DCdoublevmfunc*)     &dc_callvm_call_mips_n32
 , (DCpointervmfunc*)    &dc_callvm_call_mips_n32
+, NULL // argStruct
 };
 
 static void dc_callvm_mode_mips_n32(DCCallVM* self,DCint mode)
Index: dyncall/dyncall/dyncall_callvm_mips_o32.c
===================================================================
--- dyncall/dyncall/dyncall_callvm_mips_o32.c	
+++ dyncall/dyncall/dyncall_callvm_mips_o32.c	
@@ -199,6 +199,7 @@
 , &dc_callvm_argFloat_mips_o32
 , &dc_callvm_argDouble_mips_o32
 , &dc_callvm_argPointer_mips_o32
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_mips_o32
 , (DCboolvmfunc*)       &dc_callvm_call_mips_o32
 , (DCcharvmfunc*)       &dc_callvm_call_mips_o32
@@ -209,6 +210,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_mips_o32
 , (DCdoublevmfunc*)     &dc_callvm_call_mips_o32
 , (DCpointervmfunc*)    &dc_callvm_call_mips_o32
+, NULL // argStruct
 };
 
 DCCallVM* dcNewCallVM_mips_o32(DCsize size) 
Index: dyncall/dyncall/dyncall_signature.h
===================================================================
--- dyncall/dyncall/dyncall_signature.h	
+++ dyncall/dyncall/dyncall_signature.h	
@@ -51,7 +51,9 @@
 #define DC_SIGCHAR_DOUBLE       'd'
 #define DC_SIGCHAR_POINTER      'p'
 #define DC_SIGCHAR_STRING       'Z'
-#define DC_SIGCHAR_ENDARG       ')'
+#define DC_SIGCHAR_STRUCT       'T'
+//#define DC_SIGCHAR_ALIGN        '0' // byte value to which '0' (zero digit) will be substracted to get the alignment
+#define DC_SIGCHAR_ENDARG       ')' // also works for end struct
 
 /* callback signatures */
 
@@ -59,6 +61,7 @@
 #define DC_SIGCHAR_CC_STDCALL       's'
 #define DC_SIGCHAR_CC_FASTCALL_GNU  'f'
 #define DC_SIGCHAR_CC_FASTCALL_MS   'F'
+#define DC_SIGCHAR_CC_THISCALL_MS   '+'
 
 #endif /* DYNCALL_SIGNATURE_H */
 
Index: dyncall/dyncall/dyncall_callvm_x86.c
===================================================================
--- dyncall/dyncall/dyncall_callvm_x86.c	
+++ dyncall/dyncall/dyncall_callvm_x86.c	
@@ -23,6 +23,9 @@
 
 #include "dyncall_callvm_x86.h"
 #include "dyncall_alloc.h"
+#pragma warning(disable: 4113)
+#pragma warning(disable: 4133)
+#pragma warning(disable: 4047)
 
 void dc_callvm_mode_x86(DCCallVM* in_self, DCint mode);
 
@@ -210,6 +213,7 @@
 , &dc_callvm_argFloat_x86
 , &dc_callvm_argDouble_x86
 , &dc_callvm_argPointer_x86
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_x86_cdecl
 , (DCboolvmfunc*)       &dc_callvm_call_x86_cdecl
 , (DCcharvmfunc*)       &dc_callvm_call_x86_cdecl
@@ -220,6 +224,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x86_cdecl
 , (DCdoublevmfunc*)     &dc_callvm_call_x86_cdecl
 , (DCpointervmfunc*)    &dc_callvm_call_x86_cdecl
+, NULL // argStruct
 };
 
 DCCallVM* dcNewCallVM_x86_cdecl(DCsize size) 
@@ -255,6 +260,7 @@
 , &dc_callvm_argFloat_x86
 , &dc_callvm_argDouble_x86
 , &dc_callvm_argPointer_x86
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_x86_win32_std
 , (DCboolvmfunc*)       &dc_callvm_call_x86_win32_std
 , (DCcharvmfunc*)       &dc_callvm_call_x86_win32_std
@@ -265,6 +271,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x86_win32_std
 , (DCdoublevmfunc*)     &dc_callvm_call_x86_win32_std
 , (DCpointervmfunc*)    &dc_callvm_call_x86_win32_std
+, NULL // argStruct
 };
 
 /* win32/std callvm allocator */
@@ -364,6 +371,7 @@
 , &dc_callvm_argFloat_x86
 , &dc_callvm_argDouble_x86
 , &dc_callvm_argPointer_x86_win32_fast_ms
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_x86_win32_fast
 , (DCboolvmfunc*)       &dc_callvm_call_x86_win32_fast
 , (DCcharvmfunc*)       &dc_callvm_call_x86_win32_fast
@@ -374,6 +382,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x86_win32_fast
 , (DCdoublevmfunc*)     &dc_callvm_call_x86_win32_fast
 , (DCpointervmfunc*)    &dc_callvm_call_x86_win32_fast
+, NULL // argStruct
 };
 
 DCCallVM* dcNewCallVM_x86_win32_fast_ms(DCsize size) 
@@ -460,6 +469,7 @@
 , &dc_callvm_argFloat_x86
 , &dc_callvm_argDouble_x86
 , &dc_callvm_argPointer_x86_win32_fast_gnu
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_x86_win32_fast
 , (DCboolvmfunc*)       &dc_callvm_call_x86_win32_fast
 , (DCcharvmfunc*)       &dc_callvm_call_x86_win32_fast
@@ -470,6 +480,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x86_win32_fast
 , (DCdoublevmfunc*)     &dc_callvm_call_x86_win32_fast
 , (DCpointervmfunc*)    &dc_callvm_call_x86_win32_fast
+, NULL // argStruct
 };
 
 DCCallVM* dcNewCallVM_x86_win32_fast_gnu(DCsize size) 
@@ -503,6 +514,7 @@
 , &dc_callvm_argFloat_x86
 , &dc_callvm_argDouble_x86
 , &dc_callvm_argPointer_x86
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_x86_win32_this_ms
 , (DCboolvmfunc*)       &dc_callvm_call_x86_win32_this_ms
 , (DCcharvmfunc*)       &dc_callvm_call_x86_win32_this_ms
@@ -513,6 +525,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x86_win32_this_ms
 , (DCdoublevmfunc*)     &dc_callvm_call_x86_win32_this_ms
 , (DCpointervmfunc*)    &dc_callvm_call_x86_win32_this_ms
+, NULL // argStruct
 };
 
 /* --- syscall ------------------------------------------------------------- */
Index: dyncall/dyncall/dyncall.h
===================================================================
--- dyncall/dyncall/dyncall.h	
+++ dyncall/dyncall/dyncall.h	
@@ -44,6 +44,7 @@
 #endif
 
 typedef struct DCCallVM_    DCCallVM;
+typedef struct DCstruct_    DCstruct;
 
 /* Supported Calling Convention Modes */
 
@@ -95,6 +96,7 @@
 DC_API void       dcArgFloat      (DCCallVM* vm, DCfloat    value);
 DC_API void       dcArgDouble     (DCCallVM* vm, DCdouble   value);
 DC_API void       dcArgPointer    (DCCallVM* vm, DCpointer  value);
+DC_API void       dcArgStruct     (DCCallVM* vm, DCstruct* s, DCpointer  value);
 
 DC_API void       dcCallVoid      (DCCallVM* vm, DCpointer funcptr);
 DC_API DCbool     dcCallBool      (DCCallVM* vm, DCpointer funcptr);
@@ -106,9 +108,25 @@
 DC_API DCfloat    dcCallFloat     (DCCallVM* vm, DCpointer funcptr);
 DC_API DCdouble   dcCallDouble    (DCCallVM* vm, DCpointer funcptr);
 DC_API DCpointer  dcCallPointer   (DCCallVM* vm, DCpointer funcptr);
+DC_API void       dcCallStruct    (DCCallVM* vm, DCpointer funcptr, DCstruct* s, DCpointer returnValue);
 
 DC_API DCint      dcGetError      (DCCallVM* vm);
 
+#define DEFAULT_ALIGNMENT 0
+DC_API DCstruct*  dcNewStruct     (DCsize fieldCount, DCint alignment);
+DC_API void       dcStructField   (DCstruct* s, DCint type, DCint alignment, DCsize arrayLength);
+DC_API void       dcSubStruct     (DCstruct* s, DCsize fieldCount, DCint alignment, DCsize arrayLength);  	
+// Each dcNewStruct or dcSubStruct call must be paired with a dcCloseStruct
+DC_API void       dcCloseStruct   (DCstruct* s);  	
+DC_API DCsize     dcStructSize    (DCstruct* s);  	
+DC_API DCsize     dcStructAlignment(DCstruct* s);  	
+DC_API void       dcFreeStruct    (DCstruct* s);
+
+DC_API DCstruct*  dcDefineStruct  (const char* signature);
+
+// Internal: move to some header (dyncall_structs.h for instance)
+void dcArgStructUnroll(DCCallVM* vm, DCstruct* s, DCpointer  value);
+
 #ifdef __cplusplus
 }
 #endif
Index: dyncall/dynload/dynload_darwin.c
===================================================================
--- dyncall/dynload/dynload_darwin.c	
+++ dyncall/dynload/dynload_darwin.c	
@@ -28,6 +28,7 @@
 
 #include "dynload.h"
 #include "../dyncall/dyncall_alloc.h"
+
 #include <dlfcn.h>
 #include <string.h>
 
@@ -63,7 +64,6 @@
         return lib;
 }
 
-
 void* dlFindSymbol(DLLib* libHandle, const char* symbol)
 {
   return dlsym(libHandle && libHandle->handle ? libHandle->handle : RTLD_DEFAULT, symbol);
Index: dyncall/dynload/dynload.h
===================================================================
--- dyncall/dynload/dynload.h	
+++ dyncall/dynload/dynload.h	
@@ -24,6 +24,9 @@
 #ifndef DYNLOAD_H
 #define DYNLOAD_H
 
+
+#include "dyncall_macros.h"
+#include "dynload_macros.h"
 #include <stddef.h>
 #include <stdlib.h>
 
@@ -31,15 +34,19 @@
 extern "C" {
 #endif
 
+#ifndef DC_API
+#define DC_API
+#endif
+
 /* --- public api ---------------------------------------------------------- */
 
 /* shared library loading and explicit symbol resolving */
 
 typedef struct DLLib_ DLLib;
 
-DLLib* dlLoadLibrary(const char* libpath);
-void   dlFreeLibrary(DLLib* pLib);
-void*  dlFindSymbol(DLLib* pLib, const char* pSymbolName);
+DC_API DLLib* dlLoadLibrary(const char* libpath);
+DC_API void   dlFreeLibrary(DLLib* pLib);
+DC_API void*  dlFindSymbol(DLLib* pLib, const char* pSymbolName);
 
 /* symbol table enumeration */
 
Index: dyncall/dynload/dynload_unix.h
===================================================================
--- dyncall/dynload/dynload_unix.h	
+++ dyncall/dynload/dynload_unix.h	
@@ -0,0 +1,40 @@
+/*
+ Package: dynload
+ File: include/dynload_unix.h
+ Description: Unix-specific header file for dynload
+ License:
+
+ Copyright (c) 2011      Olivier Chafik <olivier.chafik@gmail.com>
+
+ Permission to use, copy, modify, and distribute this software for any
+ purpose with or without fee is hereby granted, provided that the above
+ copyright notice and this permission notice appear in all copies.
+
+ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+*/
+
+#ifndef DYNLOAD_UNIX_H
+#define DYNLOAD_UNIX_H
+
+
+struct DLLib_
+{
+  // Pointer to ELF header (might or might not be the same as libHandle
+  void* pElf_Ehdr; 
+  // Library handle returned by dlopen
+  void* libHandle;
+  
+  // File handle of the library, as returned by open
+  int file;
+  // Size of the library file, in bytes
+  size_t fileSize;
+};
+
+#endif // DYNLOAD_UNIX_H
Index: dyncall/dynload/dynload_windows.c
===================================================================
--- dyncall/dynload/dynload_windows.c	
+++ dyncall/dynload/dynload_windows.c	
@@ -34,6 +34,7 @@
 {
   if (libPath != NULL) {
     return (DLLib*) LoadLibraryA(libPath);
+    //return (DLLib*) LoadLibraryA(libPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
   } else {
     return (DLLib*) GetModuleHandle(NULL);
   }
Index: dyncall/dynload/dynload_syms.c
===================================================================
--- dyncall/dynload/dynload_syms.c	
+++ dyncall/dynload/dynload_syms.c	
@@ -18,11 +18,12 @@
 */
 
 #include "../dyncall/dyncall_macros.h"
+#include "dyncall_alloc.h"
 
 #if defined(DC__OS_Win32) || defined(DC__OS_Win64) || defined(DC__OS_Cygwin)
 #  include "dynload_syms_pe.c"
 #elif defined(DC_UNIX)
-#  if defined (DC__OS_Darwin) 
+#  if defined (DC__OS_Darwin)
 #    include "dynload_syms_mach-o.c"
 #  else
 #    include "dynload_syms_elf.c"
Index: dyncall/dynload/dynload_syms_mach-o.c
===================================================================
--- dyncall/dynload/dynload_syms_mach-o.c	
+++ dyncall/dynload/dynload_syms_mach-o.c	
@@ -33,9 +33,11 @@
 
 #if defined(DC__Arch_AMD64)
 #define MACH_HEADER_TYPE mach_header_64
+#define SEGMENT_COMMAND segment_command_64
 #define NLIST_TYPE nlist_64
 #else
 #define MACH_HEADER_TYPE mach_header
+#define SEGMENT_COMMAND segment_command
 #define NLIST_TYPE nlist
 #endif
 
@@ -67,8 +69,13 @@
 		const char* name = _dyld_get_image_name(iImage);
 		if (name && !strcmp(name, pLib->libPath))
 		{
-			const struct mach_header* pHeader = _dyld_get_image_header(iImage);
-			const char* pBase = (const char*)pHeader;
+			const struct MACH_HEADER_TYPE* pHeader = _dyld_get_image_header(iImage);
+			const char* pBase = ((const char*)pHeader);
+			if (pHeader->filetype != MH_DYLIB)
+				return NULL;
+			if (pHeader->flags & MH_SPLIT_SEGS)
+				return NULL;
+
 			if (pHeader)
 			{
 				uint32_t iCmd, nCmds = pHeader->ncmds;
@@ -106,7 +113,6 @@
 	dcFreeMem(pSyms);
 }
 
-
 int dlSymsCount(DLSyms* pSyms)
 {
 	if (!pSyms)
@@ -114,7 +120,6 @@
 	return pSyms->symbolCount;
 }
 
-
 static const struct NLIST_TYPE* get_nlist(DLSyms* pSyms, int index)
 {
 	const struct NLIST_TYPE* nl;
Index: dyncall/dynload/dynload.c
===================================================================
--- dyncall/dynload/dynload.c	
+++ dyncall/dynload/dynload.c	
@@ -19,10 +19,12 @@
 
 #include "dynload.h"
 #include "../dyncall/dyncall_macros.h"
+//#include "dyncall_alloc.h"
+
 #if defined(DC_WINDOWS)
 #  include "dynload_windows.c"
 #elif defined(DC_UNIX)
-#  if defined (DC__OS_Darwin)
+#  if defined(DC__OS_Darwin)
 #    include "dynload_darwin.c"
 #  else
 #    include "dynload_unix.c"
Index: dyncall/dynload/dynload_syms_elf.c
===================================================================
--- dyncall/dynload/dynload_syms_elf.c	
+++ dyncall/dynload/dynload_syms_elf.c	
@@ -20,6 +20,7 @@
 
 #if defined(DC__OS_Linux) && !defined(_GNU_SOURCE)
 #define _GNU_SOURCE
+#define __USE_GNU
 #endif
 
 /*
@@ -30,21 +31,27 @@
 
 #include "dynload.h"
 #include "dynload_macros.h"
+#include "dynload_unix.h"
 #if defined(DC__OS_OpenBSD)
 #	include <elf_abi.h>
 #else
 #	include <elf.h>
 #endif
+#if defined(DC__OS_SunOS)
+#   include <link.h>
+#endif
 #include "../dyncall/dyncall_alloc.h"
 #include <assert.h>
 #include <dlfcn.h>
 #include <stdio.h>
+#include <string.h>
 
 /* run-time configuration 64/32 */
 
 #ifdef DL__BinaryFormat_elf64
 typedef Elf64_Ehdr   Elf_Ehdr;
 typedef Elf64_Phdr   Elf_Phdr;
+typedef Elf64_Shdr   Elf_Shdr;
 typedef Elf64_Sym    Elf_Sym;
 typedef Elf64_Dyn    Elf_Dyn;
 typedef Elf64_Sxword Elf_tag;
@@ -52,368 +59,107 @@
 #else
 typedef Elf32_Ehdr   Elf_Ehdr;
 typedef Elf32_Phdr   Elf_Phdr;
+typedef Elf32_Shdr   Elf_Shdr;
 typedef Elf32_Sym    Elf_Sym;
 typedef Elf32_Dyn    Elf_Dyn;
 typedef Elf32_Sword  Elf_tag;
 typedef Elf32_Addr   Elf_Addr;
 #endif
 
-
-struct DLLib_
-{
-  Elf_Ehdr* pElf_Ehdr;
-};
-
-
-typedef struct 
-{
-  uint32_t nbucket;        
-  uint32_t nchain;         /* the total size of symbols */
-
-  /* 
-
-   it follows two arrays ...
-   
-   uint32_t bucket[nbucket-1] 
-   uint32_t chain[nchain-1]      
-
-  */
-
-} Elf_Hash;
-
-
-typedef struct {
-  uint32_t nbuckets; /* the number of buckets */
-  uint32_t symndx; /* The dynamic symbol table has dynsymcount symbols. symndx is the index of
-  the first symbol in the dynamic symbol table that is to be accessible via the hash table.
-  This implies that there are (dynsymcount - index) symbols accessible  via the hash table.
-  */
-  uint32_t maskwords; /* the number of ELFCLASS sized words in the Bloom filter portion of the hash table section.
-  This value must be non-zero, and must be a power of 2 as explained below.
-
-  Note that a value of 0 could be interpreted to mean that no Bloom filter is present in the hash section.
-  However, the GNU linkers do not do this -- the GNU hash section always includes at least 1 mask word.
-  */
-  uint32_t shift2; /* A shift count used by the Bloom filter. */
-
-  /* Following ... 
-
-  Elf_Addr bloom[maskwords];  // bloom filter to rapidly reject attempts to look up symbols.
-  uint32_t buckets[nbuckets]; // an Array of nbucket 32-bit hash values.
-  uint32_t chain[dynsymcount - symndx];
-  
-  */
-} Elf_GNU_Hash;
-
-
 struct DLSyms_
 {
   const char* pStrTab;
-  Elf_Hash*   pHash;
   Elf_Sym*    pSymTab;
-  Elf_GNU_Hash* pGNUHash;
-  uint32_t*     pGNUHashChain;
+  size_t strTabSize;
+  size_t nSymbols;
+  DLLib*      pLib;
 };
 
-
 DLSyms* dlSymsInit(DLLib* pLib)
 {
   DLSyms* pSyms;
+  Elf_Ehdr* pH;
   if(!pLib)
     return NULL;
    
   pSyms = (DLSyms*)dcAllocMem(sizeof(DLSyms));
-  pSyms->pStrTab  = 0;
-  pSyms->pSymTab  = 0;
-  pSyms->pHash    = 0;
-  pSyms->pGNUHash = 0;
-  pSyms->pGNUHashChain = 0;
+  memset(pSyms, 0, sizeof(DLSyms));
+  pSyms->pLib     = pLib;
 
-  Elf_Ehdr* pH   = pLib->pElf_Ehdr;
+  pH   = (Elf_Ehdr*)pLib->pElf_Ehdr;
 #ifdef DL__BinaryFormat_elf32
   assert( pH->e_ident[EI_CLASS] == ELFCLASS32 );
 #else
   assert( pH->e_ident[EI_CLASS] == ELFCLASS64 );
 #endif
-
+	
   assert(pH->e_phoff > 0);
   assert(pH->e_shoff > 0);
+  
   unsigned char* pMem = (unsigned char*) pH;
   Elf_Phdr* pP = (Elf_Phdr*) ( pMem + pH->e_phoff );
   
   int i; 
-
-  /* traverse run-time program headers */
-  
-  for (i=0;i<pH->e_phnum;++i)
+  /* traverse section headers */
+  Elf_Shdr* pS = (Elf_Shdr*) ( pMem + pH->e_shoff );
+  /* skip section 0 which is always zero due to the Elf standard. */
+  for (i = 1; i < pH->e_shnum; i++) 
   {
-    Elf_Phdr* p = &pP[i];
-    switch( p->p_type )
+    Elf_Shdr* pSection = &pS[i];
+    void* pSectionContent = ((char*)pMem) + pSection->sh_offset;
+    switch( pSection->sh_type )
     {
-      case PT_DYNAMIC:
-        {
-          Elf_Dyn* pDyn = (Elf_Dyn*) ( pMem + p->p_vaddr );
-          int sSymEnt = -1;
-          int sStrSz = -1;
-          for(;;) {
-            Elf_tag dt = pDyn->d_tag;
-            if (dt == DT_NULL) break;
-            switch(dt)
-            {
-              case DT_STRTAB:   pSyms->pStrTab  = (const char*)   pDyn->d_un.d_ptr; break;
-              case DT_SYMTAB:   pSyms->pSymTab  = (Elf_Sym*)      pDyn->d_un.d_ptr; break;
-              case DT_HASH:     pSyms->pHash    = (Elf_Hash*)     pDyn->d_un.d_ptr; break;
-/* this one was not defined on dyncall.org machine */
-#if defined DT_GNU_HASH
-              case DT_GNU_HASH: pSyms->pGNUHash = (Elf_GNU_Hash*) pDyn->d_un.d_ptr; break;
-#endif
-            }
-            pDyn++;
-          }
-
+      case SHT_DYNSYM:
+        if (!pSyms->pSymTab) {
+          pSyms->pSymTab  = (Elf_Sym*)pSectionContent;
+          pSyms->nSymbols = pSection->sh_size / pSection->sh_entsize;
         }
         break;
+      case SHT_STRTAB:
+        // Do not trust pH->e_shstrndx !
+        if (!pSyms->pStrTab) {
+          pSyms->pStrTab  = (const char*)pSectionContent;
+          pSyms->strTabSize = pSection->sh_size;
+        }
+        break;
     }
-  }
-  if (pSyms->pGNUHash) {
-    Elf_GNU_Hash* p = pSyms->pGNUHash;
-    Elf_Addr* pbloom = (Elf_Addr*) ( &p[1] );
-    uint32_t* pbuckets = (uint32_t*) &pbloom[p->maskwords];
-    uint32_t* pchain   = (uint32_t*) &pbuckets[p->nbuckets];
-    pSyms->pGNUHashChain = pchain;
-  }
+    if (pSyms->pSymTab && pSyms->pStrTab)
+      break;
+  }  
   return pSyms;
 }
 
-
 void dlSymsCleanup(DLSyms* pSyms)
 {
   dcFreeMem(pSyms);
 }
 
-
 int dlSymsCount(DLSyms* pSyms)
 {
-  if (!pSyms || !pSyms->pHash)
+  if (!pSyms)
     return 0;
-
-  if (pSyms->pGNUHash) {
-    return pSyms->pHash->nchain - pSyms->pGNUHash->symndx;
-  } else {
-    return pSyms->pHash->nchain;
-  }
+  return pSyms->nSymbols;
 }
 
-
 const char* dlSymsName(DLSyms* pSyms, int index)
 {
-  int export_base;
-  if(!pSyms || !pSyms->pSymTab)
+  if(!pSyms || !pSyms->pSymTab || index < 0 || index >= pSyms->nSymbols)
     return NULL;
-
-  if (pSyms->pGNUHash) {
-    export_base = pSyms->pGNUHash->symndx;
-  } else {
-    export_base = 0;
-  }
-  int str_index = pSyms->pSymTab[ export_base + index ].st_name;
+  
+  int str_index = pSyms->pSymTab[ index ].st_name;
+  if (str_index < 0 || str_index >= pSyms->strTabSize)
+    return NULL;
   return &pSyms->pStrTab[str_index];
 }
 
-
 void* dlSymsValue(DLSyms* pSyms, int index)
 {
-  int export_base;
-  if(!pSyms || !pSyms->pSymTab)
+  if(!pSyms || !pSyms->pSymTab || index < 0 || index >= pSyms->nSymbols)
     return NULL;
 
-  if (pSyms->pGNUHash) {
-    export_base = pSyms->pGNUHash->symndx;
-  } else {
-    export_base = 0;
-  }
-  return (void*) pSyms->pSymTab[ export_base + index ].st_value;
+  return dlFindSymbol(pSyms->pLib, dlSymsName(pSyms, index));
 }
 
-
-#if 0
-
-/*
- * the "gnu hash" / DJB hash function
- */
-
-uint32_t
-dl_new_hash(const char* s)
-{
-  uint32_t h = 5381;
-  for (unsigned char c = *s; c != '\0' ; c = *++s)
-    h = h * 33 + c;
-  return h;
-}
-
-
-/* GNU binutils implementation: */
-static uint_fast32_t
-dl_new_hash(const char* s)
-{
-  uint_fast32_t h = 5381;
-  for (unsigned char c = *s; c != '\0' ; c = *++s)
-    h = h * 33 + c;
-  return h & 0xffffffff;
-}
-#endif
-
-
-#if 0
-/*
- * the hash function 
- */
-unsigned long
-elf_hash(const unsigned char* name)
-{
-  unsigned long h = 0, g;
-  while(*name) {
-    h = (h << 4) + *name++;
-    if (g = h & 0xf0000000)
-      h ^= g >> 24;
-    h &= ~g;
-  }
-  return h;
-}
-#endif
-
-
-#if 0
-void dlInitSyms_elf64(DLSyms* pResolver, DLLib* pLib)
-{
-  pResolver->elf64 = 1;
-  Elf64_Ehdr* pH   = pLib->u.pElf64_Ehdr;
-  assert(pH->e_phoff > 0);
-  assert(pH->e_shoff > 0);
-  DLubyte* pMem = (DLubyte*) pH;
-  Elf64_Phdr* pP = (Elf64_Phdr*) ( pMem + pH->e_phoff );
-  
-  int i; 
-
-  /* traverse run-time program headers */
-  
-  int pi_dynamic = -1;
-  for (i=0;i<pH->e_phnum;++i)
-  {
-    Elf64_Phdr* p = &pP[i];
-    switch( p->p_type )
-    {
-      case PT_DYNAMIC:
-        {
-          pi_dynamic = i;
-          Elf64_Dyn* pDyn = (Elf64_Dyn*) ( pMem + p->p_vaddr );
-          int sSymEnt = -1;
-          int sStrSz = -1;
-          for(;;) {
-            Elf64_Sxword dt = pDyn->d_tag;
-            if (dt == DT_NULL) break;
-            switch(dt)
-            {
-              case DT_STRTAB: pResolver->pStrTab = (const char*) pDyn->d_un.d_ptr; break;
-              case DT_SYMTAB: pResolver->u.pSymTab64 = (Elf64_Sym*)  pDyn->d_un.d_ptr; break;
-              case DT_HASH:   pResolver->pHash =   (Elf_Hash*) pDyn->d_un.d_ptr; break;
-              // case DT_SYMENT: sSymEnt = (int) pDyn->d_un.d_val; break;
-              // case DT_STRSZ:  sStrSz  = (int) pDyn->d_un.d_val; break;
-              // case DT_SYMBOLIC: printf("symbolic!\n"); break;
-              // case DT_STRTAB: pS_StrTab = (Elf64_Shdr*) pDyn->d_un.d_ptr; break;
-              // case DT_SYMTAB: pS_SymTab = (Elf64_Shdr*) pDyn->d_un.d_ptr; break;
-            }
-            pDyn++;
-          }
-#if 0
-          /* traversing the symbol table */
-          int j;
-          /* by convention, the first symbol table references an undefined symbol */
-          // pStrTab = &pS[ pH->e_shstrndx ];
-          for(j=1; j < pHash->nchain ;++j) {
-
-            // int name = pS_StrTab->sh_name;
-            int sti = pSymTab[j].st_name;
-
-            printf("%s\n", &pStrTab[sti] );
-
-          }
-#endif
-
-        }
-        break;
-    }
-  }
-
-#if 0
-  /* traverse section headers */
-  Elf64_Shdr* pS = (Elf64_Shdr*) ( pMem + pH->e_shoff );  
-  int dynsym = -1;
-  /* skip section 0 which is always zero due to the Elf standard. */
-  for (i=1;i<pH->e_shnum;++i) 
-  {
-    Elf64_Shdr* p= &pS[i];
-    
-    switch( p->sh_type )
-    {
-      case SHT_DYNSYM:
-        dynsym = i;
-        break;
-    }
-  }
-#endif
-
-
-  // return 0;
-}
-
-
-void dlInitSyms_elf32(DLLib* pLib)
-{
-  DLSyms* pResolver = (DLSyms*)dcAllocMem(sizeof(DLSyms));
-  pResolver->elf64 = 0;
-  Elf32_Ehdr* pH   = pLib->u.pElf32_Ehdr;
-  assert(pH->e_phoff > 0);
-  assert(pH->e_shoff > 0);
-  DLubyte* pMem = (DLubyte*) pH;
-  Elf32_Phdr* pP = (Elf32_Phdr*) ( pMem + pH->e_phoff );
-  
-  int i; 
-
-  /* traverse run-time program headers */
-  
-  int pi_dynamic = -1;
-  for (i=0;i<pH->e_phnum;++i)
-  {
-    Elf32_Phdr* p = &pP[i];
-    switch( p->p_type )
-    {
-      case PT_DYNAMIC:
-        {
-          pi_dynamic = i;
-          Elf32_Dyn* pDyn = (Elf32_Dyn*) ( pMem + p->p_vaddr );
-          int sSymEnt = -1;
-          int sStrSz = -1;
-          for(;;) {
-            Elf32_Sword dt = pDyn->d_tag;
-            if (dt == DT_NULL) break;
-            switch(dt)
-            {
-              case DT_STRTAB: pResolver->pStrTab = (const char*) pDyn->d_un.d_ptr; break;
-              case DT_SYMTAB: pResolver->u.pSymTab32 = (Elf32_Sym*)  pDyn->d_un.d_ptr; break;
-              case DT_HASH:   pResolver->pHash =   (Elf_Hash*) pDyn->d_un.d_ptr; break;
-            }
-            pDyn++;
-          }
-
-        }
-        break;
-    }
-  }
-}
-#endif
-
-
 const char* dlSymsNameFromValue(DLSyms* pSyms, void* value)
 {
   Dl_info info;
Index: dyncall/dynload/dynload_unix.c
===================================================================
--- dyncall/dynload/dynload_unix.c	
+++ dyncall/dynload/dynload_unix.c	
@@ -25,23 +25,56 @@
 
 */
 
+#if defined(DC__OS_Linux) && !defined(_GNU_SOURCE)
+#define _GNU_SOURCE
+#define __USE_GNU
+#endif
 
 #include "dynload.h"
+#include "dynload_unix.h"
 
 #include <dlfcn.h>
+#include <sys/mman.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include <sys/fcntl.h>
 
 DLLib* dlLoadLibrary(const char* libPath)
 {
-  return (DLLib*) dlopen(libPath,RTLD_NOW);
+  DLLib* pLib;
+  struct stat st;
+  void* pHandle = dlopen(libPath, RTLD_LAZY | RTLD_GLOBAL);
+  if (!pHandle)
+    return NULL;
+  
+  pLib = (DLLib*)malloc(sizeof(DLLib));
+  pLib->libHandle = pHandle;
+  	  
+  pLib->file = open(libPath, O_RDONLY);
+  stat(libPath, &st);
+  pLib->fileSize = st.st_size;
+  pLib->pElf_Ehdr = mmap(NULL, pLib->fileSize, PROT_READ, MAP_SHARED, pLib->file, 0);
+  /* 
+  Old hack on Linux :
+  typedef struct DLOpenHandle_
+  {
+    void* pElf_Ehdr;
+  } DLOpenHandle;
+  pLib->pElf_Ehdr = ((DLOpenHandle*)pHandle)->pElf_Ehdr;
+  */
+  return pLib;
 }
 
-void* dlFindSymbol(DLLib* libHandle, const char* symbol)
+void* dlFindSymbol(DLLib* pLib, const char* symbol)
 {
-  return dlsym( (void*) libHandle, symbol);
+  return dlsym(pLib ? pLib->libHandle : RTLD_DEFAULT, symbol);
 }
 
-void  dlFreeLibrary(DLLib* libHandle)
+void  dlFreeLibrary(DLLib* pLib)
 {
-  dlclose( (void*) libHandle);
+  munmap(pLib->pElf_Ehdr, pLib->fileSize);
+  close(pLib->file);
+  dlclose(pLib->libHandle);
+  free(pLib);
 }
 
Index: dyncall/buildsys/gmake/prolog.gmake
===================================================================
--- dyncall/buildsys/gmake/prolog.gmake	
+++ dyncall/buildsys/gmake/prolog.gmake	
@@ -28,6 +28,7 @@
 
 # config settings
 
+#$(if $(wildcard "${TOP}/ConfigVars"),$(error hmm),$(error File 'ConfigVars' not found at top directory. Run 'configure' - or, if you use CMake, run 'make -f Makefile' please.))
 ifeq ($(wildcard $(TOP)/ConfigVars),)
 $(error File 'ConfigVars' not found at top directory. Run 'configure' - or, if you use CMake, run 'make -f Makefile' please.)
 else
