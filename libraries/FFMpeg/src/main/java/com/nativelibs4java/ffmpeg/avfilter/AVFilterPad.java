package com.nativelibs4java.ffmpeg.avfilter;
import com.nativelibs4java.ffmpeg.avcodec.AvcodecLibrary.AVSampleFormat;
import org.bridj.Callback;
import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
/**
 * A filter pad used for either input or output.<br>
 * <i>native declaration : libavfilter/avfilter.h:310</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.free.fr/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("avfilter") 
public class AVFilterPad extends StructObject {
	public AVFilterPad() {
		super();
	}
	public AVFilterPad(Pointer pointer) {
		super(pointer);
	}
	/**
	 * Pad name. The name is unique among inputs and among outputs, but an<br>
	 * input may have the same name as an output. This may be NULL if this<br>
	 * pad has no need to ever be referenced by name.<br>
	 * C type : const char*
	 */
	@Field(0) 
	public Pointer<Byte > name() {
		return this.io.getPointerField(this, 0);
	}
	/**
	 * Pad name. The name is unique among inputs and among outputs, but an<br>
	 * input may have the same name as an output. This may be NULL if this<br>
	 * pad has no need to ever be referenced by name.<br>
	 * C type : const char*
	 */
	@Field(0) 
	public AVFilterPad name(Pointer<Byte > name) {
		this.io.setPointerField(this, 0, name);
		return this;
	}
	/// C type : const char*
	public final Pointer<Byte > name_$eq(Pointer<Byte > name) {
		name(name);
		return name;
	}
	/**
	 * Minimum required permissions on incoming buffers. Any buffer with<br>
	 * insufficient permissions will be automatically copied by the filter<br>
	 * system to a new buffer which provides the needed access permissions.<br>
	 * * Input pads only.
	 */
	@Field(2) 
	public int min_perms() {
		return this.io.getIntField(this, 2);
	}
	/**
	 * Minimum required permissions on incoming buffers. Any buffer with<br>
	 * insufficient permissions will be automatically copied by the filter<br>
	 * system to a new buffer which provides the needed access permissions.<br>
	 * * Input pads only.
	 */
	@Field(2) 
	public AVFilterPad min_perms(int min_perms) {
		this.io.setIntField(this, 2, min_perms);
		return this;
	}
	public final int min_perms_$eq(int min_perms) {
		min_perms(min_perms);
		return min_perms;
	}
	/**
	 * Permissions which are not accepted on incoming buffers. Any buffer<br>
	 * which has any of these permissions set will be automatically copied<br>
	 * by the filter system to a new buffer which does not have those<br>
	 * permissions. This can be used to easily disallow buffers with<br>
	 * AV_PERM_REUSE.<br>
	 * * Input pads only.
	 */
	@Field(3) 
	public int rej_perms() {
		return this.io.getIntField(this, 3);
	}
	/**
	 * Permissions which are not accepted on incoming buffers. Any buffer<br>
	 * which has any of these permissions set will be automatically copied<br>
	 * by the filter system to a new buffer which does not have those<br>
	 * permissions. This can be used to easily disallow buffers with<br>
	 * AV_PERM_REUSE.<br>
	 * * Input pads only.
	 */
	@Field(3) 
	public AVFilterPad rej_perms(int rej_perms) {
		this.io.setIntField(this, 3, rej_perms);
		return this;
	}
	public final int rej_perms_$eq(int rej_perms) {
		rej_perms(rej_perms);
		return rej_perms;
	}
	/**
	 * Callback called before passing the first slice of a new frame. If<br>
	 * NULL, the filter layer will default to storing a reference to the<br>
	 * picture inside the link structure.<br>
	 * * Input video pads only.<br>
	 * C type : start_frame_callback
	 */
	@Field(4) 
	public Pointer<AVFilterPad.start_frame_callback > start_frame() {
		return this.io.getPointerField(this, 4);
	}
	/**
	 * Callback called before passing the first slice of a new frame. If<br>
	 * NULL, the filter layer will default to storing a reference to the<br>
	 * picture inside the link structure.<br>
	 * * Input video pads only.<br>
	 * C type : start_frame_callback
	 */
	@Field(4) 
	public AVFilterPad start_frame(Pointer<AVFilterPad.start_frame_callback > start_frame) {
		this.io.setPointerField(this, 4, start_frame);
		return this;
	}
	/// C type : start_frame_callback
	public final Pointer<AVFilterPad.start_frame_callback > start_frame_$eq(Pointer<AVFilterPad.start_frame_callback > start_frame) {
		start_frame(start_frame);
		return start_frame;
	}
	/**
	 * Callback function to get a video buffer. If NULL, the filter system will<br>
	 * use avfilter_default_get_video_buffer().<br>
	 * * Input video pads only.<br>
	 * C type : get_video_buffer_callback
	 */
	@Field(5) 
	public Pointer<AVFilterPad.get_video_buffer_callback > get_video_buffer() {
		return this.io.getPointerField(this, 5);
	}
	/**
	 * Callback function to get a video buffer. If NULL, the filter system will<br>
	 * use avfilter_default_get_video_buffer().<br>
	 * * Input video pads only.<br>
	 * C type : get_video_buffer_callback
	 */
	@Field(5) 
	public AVFilterPad get_video_buffer(Pointer<AVFilterPad.get_video_buffer_callback > get_video_buffer) {
		this.io.setPointerField(this, 5, get_video_buffer);
		return this;
	}
	/// C type : get_video_buffer_callback
	public final Pointer<AVFilterPad.get_video_buffer_callback > get_video_buffer_$eq(Pointer<AVFilterPad.get_video_buffer_callback > get_video_buffer) {
		get_video_buffer(get_video_buffer);
		return get_video_buffer;
	}
	/**
	 * Callback function to get an audio buffer. If NULL, the filter system will<br>
	 * use avfilter_default_get_audio_buffer().<br>
	 * * Input audio pads only.<br>
	 * C type : get_audio_buffer_callback
	 */
	@Field(6) 
	public Pointer<AVFilterPad.get_audio_buffer_callback > get_audio_buffer() {
		return this.io.getPointerField(this, 6);
	}
	/**
	 * Callback function to get an audio buffer. If NULL, the filter system will<br>
	 * use avfilter_default_get_audio_buffer().<br>
	 * * Input audio pads only.<br>
	 * C type : get_audio_buffer_callback
	 */
	@Field(6) 
	public AVFilterPad get_audio_buffer(Pointer<AVFilterPad.get_audio_buffer_callback > get_audio_buffer) {
		this.io.setPointerField(this, 6, get_audio_buffer);
		return this;
	}
	/// C type : get_audio_buffer_callback
	public final Pointer<AVFilterPad.get_audio_buffer_callback > get_audio_buffer_$eq(Pointer<AVFilterPad.get_audio_buffer_callback > get_audio_buffer) {
		get_audio_buffer(get_audio_buffer);
		return get_audio_buffer;
	}
	/**
	 * Callback called after the slices of a frame are completely sent. If<br>
	 * NULL, the filter layer will default to releasing the reference stored<br>
	 * in the link structure during start_frame().<br>
	 * * Input video pads only.<br>
	 * C type : end_frame_callback
	 */
	@Field(7) 
	public Pointer<AVFilterPad.end_frame_callback > end_frame() {
		return this.io.getPointerField(this, 7);
	}
	/**
	 * Callback called after the slices of a frame are completely sent. If<br>
	 * NULL, the filter layer will default to releasing the reference stored<br>
	 * in the link structure during start_frame().<br>
	 * * Input video pads only.<br>
	 * C type : end_frame_callback
	 */
	@Field(7) 
	public AVFilterPad end_frame(Pointer<AVFilterPad.end_frame_callback > end_frame) {
		this.io.setPointerField(this, 7, end_frame);
		return this;
	}
	/// C type : end_frame_callback
	public final Pointer<AVFilterPad.end_frame_callback > end_frame_$eq(Pointer<AVFilterPad.end_frame_callback > end_frame) {
		end_frame(end_frame);
		return end_frame;
	}
	/**
	 * Slice drawing callback. This is where a filter receives video data<br>
	 * and should do its processing.<br>
	 * * Input video pads only.<br>
	 * C type : draw_slice_callback
	 */
	@Field(8) 
	public Pointer<AVFilterPad.draw_slice_callback > draw_slice() {
		return this.io.getPointerField(this, 8);
	}
	/**
	 * Slice drawing callback. This is where a filter receives video data<br>
	 * and should do its processing.<br>
	 * * Input video pads only.<br>
	 * C type : draw_slice_callback
	 */
	@Field(8) 
	public AVFilterPad draw_slice(Pointer<AVFilterPad.draw_slice_callback > draw_slice) {
		this.io.setPointerField(this, 8, draw_slice);
		return this;
	}
	/// C type : draw_slice_callback
	public final Pointer<AVFilterPad.draw_slice_callback > draw_slice_$eq(Pointer<AVFilterPad.draw_slice_callback > draw_slice) {
		draw_slice(draw_slice);
		return draw_slice;
	}
	/**
	 * Samples filtering callback. This is where a filter receives audio data<br>
	 * and should do its processing.<br>
	 * * Input audio pads only.<br>
	 * C type : filter_samples_callback
	 */
	@Field(9) 
	public Pointer<AVFilterPad.filter_samples_callback > filter_samples() {
		return this.io.getPointerField(this, 9);
	}
	/**
	 * Samples filtering callback. This is where a filter receives audio data<br>
	 * and should do its processing.<br>
	 * * Input audio pads only.<br>
	 * C type : filter_samples_callback
	 */
	@Field(9) 
	public AVFilterPad filter_samples(Pointer<AVFilterPad.filter_samples_callback > filter_samples) {
		this.io.setPointerField(this, 9, filter_samples);
		return this;
	}
	/// C type : filter_samples_callback
	public final Pointer<AVFilterPad.filter_samples_callback > filter_samples_$eq(Pointer<AVFilterPad.filter_samples_callback > filter_samples) {
		filter_samples(filter_samples);
		return filter_samples;
	}
	/**
	 * Frame poll callback. This returns the number of immediately available<br>
	 * samples. It should return a positive value if the next request_frame()<br>
	 * is guaranteed to return one frame (with no delay).<br>
	 * * Defaults to just calling the source poll_frame() method.<br>
	 * * Output video pads only.<br>
	 * C type : poll_frame_callback
	 */
	@Field(10) 
	public Pointer<AVFilterPad.poll_frame_callback > poll_frame() {
		return this.io.getPointerField(this, 10);
	}
	/**
	 * Frame poll callback. This returns the number of immediately available<br>
	 * samples. It should return a positive value if the next request_frame()<br>
	 * is guaranteed to return one frame (with no delay).<br>
	 * * Defaults to just calling the source poll_frame() method.<br>
	 * * Output video pads only.<br>
	 * C type : poll_frame_callback
	 */
	@Field(10) 
	public AVFilterPad poll_frame(Pointer<AVFilterPad.poll_frame_callback > poll_frame) {
		this.io.setPointerField(this, 10, poll_frame);
		return this;
	}
	/// C type : poll_frame_callback
	public final Pointer<AVFilterPad.poll_frame_callback > poll_frame_$eq(Pointer<AVFilterPad.poll_frame_callback > poll_frame) {
		poll_frame(poll_frame);
		return poll_frame;
	}
	/**
	 * Frame request callback. A call to this should result in at least one<br>
	 * frame being output over the given link. This should return zero on<br>
	 * success, and another value on error.<br>
	 * * Output video pads only.<br>
	 * C type : request_frame_callback
	 */
	@Field(11) 
	public Pointer<AVFilterPad.request_frame_callback > request_frame() {
		return this.io.getPointerField(this, 11);
	}
	/**
	 * Frame request callback. A call to this should result in at least one<br>
	 * frame being output over the given link. This should return zero on<br>
	 * success, and another value on error.<br>
	 * * Output video pads only.<br>
	 * C type : request_frame_callback
	 */
	@Field(11) 
	public AVFilterPad request_frame(Pointer<AVFilterPad.request_frame_callback > request_frame) {
		this.io.setPointerField(this, 11, request_frame);
		return this;
	}
	/// C type : request_frame_callback
	public final Pointer<AVFilterPad.request_frame_callback > request_frame_$eq(Pointer<AVFilterPad.request_frame_callback > request_frame) {
		request_frame(request_frame);
		return request_frame;
	}
	/**
	 * Link configuration callback.<br>
	 * * For output pads, this should set the link properties such as<br>
	 * width/height. This should NOT set the format property - that is<br>
	 * negotiated between filters by the filter system using the<br>
	 * query_formats() callback before this function is called.<br>
	 * * For input pads, this should check the properties of the link, and update<br>
	 * the filter's internal state as necessary.<br>
	 * * For both input and output filters, this should return zero on success,<br>
	 * and another value on error.<br>
	 * C type : config_props_callback
	 */
	@Field(12) 
	public Pointer<AVFilterPad.config_props_callback > config_props() {
		return this.io.getPointerField(this, 12);
	}
	/**
	 * Link configuration callback.<br>
	 * * For output pads, this should set the link properties such as<br>
	 * width/height. This should NOT set the format property - that is<br>
	 * negotiated between filters by the filter system using the<br>
	 * query_formats() callback before this function is called.<br>
	 * * For input pads, this should check the properties of the link, and update<br>
	 * the filter's internal state as necessary.<br>
	 * * For both input and output filters, this should return zero on success,<br>
	 * and another value on error.<br>
	 * C type : config_props_callback
	 */
	@Field(12) 
	public AVFilterPad config_props(Pointer<AVFilterPad.config_props_callback > config_props) {
		this.io.setPointerField(this, 12, config_props);
		return this;
	}
	/// C type : config_props_callback
	public final Pointer<AVFilterPad.config_props_callback > config_props_$eq(Pointer<AVFilterPad.config_props_callback > config_props) {
		config_props(config_props);
		return config_props;
	}
	/// <i>native declaration : libavfilter/avfilter.h</i>
	public static abstract class start_frame_callback extends Callback<start_frame_callback > {
		public abstract void apply(Pointer<AVFilterLink > link, Pointer<AVFilterBufferRef > picref);
	};
	/// <i>native declaration : libavfilter/avfilter.h</i>
	public static abstract class get_video_buffer_callback extends Callback<get_video_buffer_callback > {
		public abstract Pointer<AVFilterBufferRef > apply(Pointer<AVFilterLink > link, int perms, int w, int h);
	};
	/// <i>native declaration : libavfilter/avfilter.h</i>
	public static abstract class get_audio_buffer_callback extends Callback<get_audio_buffer_callback > {
		public abstract Pointer<AVFilterBufferRef > apply(Pointer<AVFilterLink > link, int perms, AVSampleFormat sample_fmt, int size, long channel_layout, int planar);
	};
	/// <i>native declaration : libavfilter/avfilter.h</i>
	public static abstract class end_frame_callback extends Callback<end_frame_callback > {
		public abstract void apply(Pointer<AVFilterLink > link);
	};
	/// <i>native declaration : libavfilter/avfilter.h</i>
	public static abstract class draw_slice_callback extends Callback<draw_slice_callback > {
		public abstract void apply(Pointer<AVFilterLink > link, int y, int height, int slice_dir);
	};
	/// <i>native declaration : libavfilter/avfilter.h</i>
	public static abstract class filter_samples_callback extends Callback<filter_samples_callback > {
		public abstract void apply(Pointer<AVFilterLink > link, Pointer<AVFilterBufferRef > samplesref);
	};
	/// <i>native declaration : libavfilter/avfilter.h</i>
	public static abstract class poll_frame_callback extends Callback<poll_frame_callback > {
		public abstract int apply(Pointer<AVFilterLink > link);
	};
	/// <i>native declaration : libavfilter/avfilter.h</i>
	public static abstract class request_frame_callback extends Callback<request_frame_callback > {
		public abstract int apply(Pointer<AVFilterLink > link);
	};
	/// <i>native declaration : libavfilter/avfilter.h</i>
	public static abstract class config_props_callback extends Callback<config_props_callback > {
		public abstract int apply(Pointer<AVFilterLink > link);
	};
}
