package com.nativelibs4java.ffmpeg.avformat;
import com.nativelibs4java.ffmpeg.avcodec.AVPacket;
import com.nativelibs4java.ffmpeg.avformat.AvformatLibrary.AVCodecTag;
import com.nativelibs4java.ffmpeg.avformat.AvformatLibrary.AVMetadataConv;
import org.bridj.Callback;
import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
/**
 * <i>native declaration : libavformat/avformat.h</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.free.fr/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("avformat") 
public class AVInputFormat extends StructObject {
	public AVInputFormat() {
		super();
	}
	public AVInputFormat(Pointer pointer) {
		super(pointer);
	}
	/**
	 * A comma separated list of short names for the format. New names<br>
	 * may be appended with a minor bump.<br>
	 * C type : const char*
	 */
	@Field(0) 
	public Pointer<Byte > name() {
		return this.io.getPointerField(this, 0);
	}
	/**
	 * A comma separated list of short names for the format. New names<br>
	 * may be appended with a minor bump.<br>
	 * C type : const char*
	 */
	@Field(0) 
	public AVInputFormat name(Pointer<Byte > name) {
		this.io.setPointerField(this, 0, name);
		return this;
	}
	/// C type : const char*
	public final Pointer<Byte > name_$eq(Pointer<Byte > name) {
		name(name);
		return name;
	}
	/**
	 * Descriptive name for the format, meant to be more human-readable<br>
	 * than name. You should use the NULL_IF_CONFIG_SMALL() macro<br>
	 * to define it.<br>
	 * C type : const char*
	 */
	@Field(1) 
	public Pointer<Byte > long_name() {
		return this.io.getPointerField(this, 1);
	}
	/**
	 * Descriptive name for the format, meant to be more human-readable<br>
	 * than name. You should use the NULL_IF_CONFIG_SMALL() macro<br>
	 * to define it.<br>
	 * C type : const char*
	 */
	@Field(1) 
	public AVInputFormat long_name(Pointer<Byte > long_name) {
		this.io.setPointerField(this, 1, long_name);
		return this;
	}
	/// C type : const char*
	public final Pointer<Byte > long_name_$eq(Pointer<Byte > long_name) {
		long_name(long_name);
		return long_name;
	}
	/// Size of private data so that it can be allocated in the wrapper.
	@Field(2) 
	public int priv_data_size() {
		return this.io.getIntField(this, 2);
	}
	/// Size of private data so that it can be allocated in the wrapper.
	@Field(2) 
	public AVInputFormat priv_data_size(int priv_data_size) {
		this.io.setIntField(this, 2, priv_data_size);
		return this;
	}
	public final int priv_data_size_$eq(int priv_data_size) {
		priv_data_size(priv_data_size);
		return priv_data_size;
	}
	/**
	 * Tell if a given file has a chance of being parsed as this format.<br>
	 * The buffer provided is guaranteed to be AVPROBE_PADDING_SIZE bytes<br>
	 * big so you do not have to check for that unless you need more.<br>
	 * C type : read_probe_callback
	 */
	@Field(3) 
	public Pointer<AVInputFormat.read_probe_callback > read_probe() {
		return this.io.getPointerField(this, 3);
	}
	/**
	 * Tell if a given file has a chance of being parsed as this format.<br>
	 * The buffer provided is guaranteed to be AVPROBE_PADDING_SIZE bytes<br>
	 * big so you do not have to check for that unless you need more.<br>
	 * C type : read_probe_callback
	 */
	@Field(3) 
	public AVInputFormat read_probe(Pointer<AVInputFormat.read_probe_callback > read_probe) {
		this.io.setPointerField(this, 3, read_probe);
		return this;
	}
	/// C type : read_probe_callback
	public final Pointer<AVInputFormat.read_probe_callback > read_probe_$eq(Pointer<AVInputFormat.read_probe_callback > read_probe) {
		read_probe(read_probe);
		return read_probe;
	}
	/**
	 * Read the format header and initialize the AVFormatContext<br>
	 * structure. Return 0 if OK. 'ap' if non-NULL contains<br>
	 * additional parameters. Only used in raw format right<br>
	 * now. 'av_new_stream' should be called to create new streams.<br>
	 * C type : read_header_callback
	 */
	@Field(4) 
	public Pointer<AVInputFormat.read_header_callback > read_header() {
		return this.io.getPointerField(this, 4);
	}
	/**
	 * Read the format header and initialize the AVFormatContext<br>
	 * structure. Return 0 if OK. 'ap' if non-NULL contains<br>
	 * additional parameters. Only used in raw format right<br>
	 * now. 'av_new_stream' should be called to create new streams.<br>
	 * C type : read_header_callback
	 */
	@Field(4) 
	public AVInputFormat read_header(Pointer<AVInputFormat.read_header_callback > read_header) {
		this.io.setPointerField(this, 4, read_header);
		return this;
	}
	/// C type : read_header_callback
	public final Pointer<AVInputFormat.read_header_callback > read_header_$eq(Pointer<AVInputFormat.read_header_callback > read_header) {
		read_header(read_header);
		return read_header;
	}
	/**
	 * Read one packet and put it in 'pkt'. pts and flags are also<br>
	 * set. 'av_new_stream' can be called only if the flag<br>
	 * AVFMTCTX_NOHEADER is used and only in the calling thread (not in a<br>
	 * background thread).<br>
	 * @return 0 on success, < 0 on error.<br>
	 *         When returning an error, pkt must not have been allocated<br>
	 *         or must be freed before returning<br>
	 * C type : read_packet_callback
	 */
	@Field(5) 
	public Pointer<AVInputFormat.read_packet_callback > read_packet() {
		return this.io.getPointerField(this, 5);
	}
	/**
	 * Read one packet and put it in 'pkt'. pts and flags are also<br>
	 * set. 'av_new_stream' can be called only if the flag<br>
	 * AVFMTCTX_NOHEADER is used and only in the calling thread (not in a<br>
	 * background thread).<br>
	 * @return 0 on success, < 0 on error.<br>
	 *         When returning an error, pkt must not have been allocated<br>
	 *         or must be freed before returning<br>
	 * C type : read_packet_callback
	 */
	@Field(5) 
	public AVInputFormat read_packet(Pointer<AVInputFormat.read_packet_callback > read_packet) {
		this.io.setPointerField(this, 5, read_packet);
		return this;
	}
	/// C type : read_packet_callback
	public final Pointer<AVInputFormat.read_packet_callback > read_packet_$eq(Pointer<AVInputFormat.read_packet_callback > read_packet) {
		read_packet(read_packet);
		return read_packet;
	}
	/**
	 * Close the stream. The AVFormatContext and AVStreams are not<br>
	 * freed by this function<br>
	 * C type : read_close_callback
	 */
	@Field(6) 
	public Pointer<AVInputFormat.read_close_callback > read_close() {
		return this.io.getPointerField(this, 6);
	}
	/**
	 * Close the stream. The AVFormatContext and AVStreams are not<br>
	 * freed by this function<br>
	 * C type : read_close_callback
	 */
	@Field(6) 
	public AVInputFormat read_close(Pointer<AVInputFormat.read_close_callback > read_close) {
		this.io.setPointerField(this, 6, read_close);
		return this;
	}
	/// C type : read_close_callback
	public final Pointer<AVInputFormat.read_close_callback > read_close_$eq(Pointer<AVInputFormat.read_close_callback > read_close) {
		read_close(read_close);
		return read_close;
	}
	/**
	 * Seek to a given timestamp relative to the frames in<br>
	 * stream component stream_index.<br>
	 * @param stream_index Must not be -1.<br>
	 * @param flags Selects which direction should be preferred if no exact<br>
	 *              match is available.<br>
	 * @return >= 0 on success (but not necessarily the new offset)<br>
	 * C type : read_seek_callback
	 */
	@Field(7) 
	public Pointer<AVInputFormat.read_seek_callback > read_seek() {
		return this.io.getPointerField(this, 7);
	}
	/**
	 * Seek to a given timestamp relative to the frames in<br>
	 * stream component stream_index.<br>
	 * @param stream_index Must not be -1.<br>
	 * @param flags Selects which direction should be preferred if no exact<br>
	 *              match is available.<br>
	 * @return >= 0 on success (but not necessarily the new offset)<br>
	 * C type : read_seek_callback
	 */
	@Field(7) 
	public AVInputFormat read_seek(Pointer<AVInputFormat.read_seek_callback > read_seek) {
		this.io.setPointerField(this, 7, read_seek);
		return this;
	}
	/// C type : read_seek_callback
	public final Pointer<AVInputFormat.read_seek_callback > read_seek_$eq(Pointer<AVInputFormat.read_seek_callback > read_seek) {
		read_seek(read_seek);
		return read_seek;
	}
	/**
	 * Gets the next timestamp in stream[stream_index].time_base units.<br>
	 * @return the timestamp or AV_NOPTS_VALUE if an error occurred<br>
	 * C type : read_timestamp_callback
	 */
	@Field(8) 
	public Pointer<AVInputFormat.read_timestamp_callback > read_timestamp() {
		return this.io.getPointerField(this, 8);
	}
	/**
	 * Gets the next timestamp in stream[stream_index].time_base units.<br>
	 * @return the timestamp or AV_NOPTS_VALUE if an error occurred<br>
	 * C type : read_timestamp_callback
	 */
	@Field(8) 
	public AVInputFormat read_timestamp(Pointer<AVInputFormat.read_timestamp_callback > read_timestamp) {
		this.io.setPointerField(this, 8, read_timestamp);
		return this;
	}
	/// C type : read_timestamp_callback
	public final Pointer<AVInputFormat.read_timestamp_callback > read_timestamp_$eq(Pointer<AVInputFormat.read_timestamp_callback > read_timestamp) {
		read_timestamp(read_timestamp);
		return read_timestamp;
	}
	/// Can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER.
	@Field(9) 
	public int flags() {
		return this.io.getIntField(this, 9);
	}
	/// Can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER.
	@Field(9) 
	public AVInputFormat flags(int flags) {
		this.io.setIntField(this, 9, flags);
		return this;
	}
	public final int flags_$eq(int flags) {
		flags(flags);
		return flags;
	}
	/**
	 * If extensions are defined, then no probe is done. You should<br>
	 * usually not use extension format guessing because it is not<br>
	 * reliable enough<br>
	 * C type : const char*
	 */
	@Field(10) 
	public Pointer<Byte > extensions() {
		return this.io.getPointerField(this, 10);
	}
	/**
	 * If extensions are defined, then no probe is done. You should<br>
	 * usually not use extension format guessing because it is not<br>
	 * reliable enough<br>
	 * C type : const char*
	 */
	@Field(10) 
	public AVInputFormat extensions(Pointer<Byte > extensions) {
		this.io.setPointerField(this, 10, extensions);
		return this;
	}
	/// C type : const char*
	public final Pointer<Byte > extensions_$eq(Pointer<Byte > extensions) {
		extensions(extensions);
		return extensions;
	}
	/// General purpose read-only value that the format can use.
	@Field(11) 
	public int value() {
		return this.io.getIntField(this, 11);
	}
	/// General purpose read-only value that the format can use.
	@Field(11) 
	public AVInputFormat value(int value) {
		this.io.setIntField(this, 11, value);
		return this;
	}
	public final int value_$eq(int value) {
		value(value);
		return value;
	}
	/**
	 * Start/resume playing - only meaningful if using a network-based format<br>
	 * (RTSP).<br>
	 * C type : read_play_callback
	 */
	@Field(12) 
	public Pointer<AVInputFormat.read_play_callback > read_play() {
		return this.io.getPointerField(this, 12);
	}
	/**
	 * Start/resume playing - only meaningful if using a network-based format<br>
	 * (RTSP).<br>
	 * C type : read_play_callback
	 */
	@Field(12) 
	public AVInputFormat read_play(Pointer<AVInputFormat.read_play_callback > read_play) {
		this.io.setPointerField(this, 12, read_play);
		return this;
	}
	/// C type : read_play_callback
	public final Pointer<AVInputFormat.read_play_callback > read_play_$eq(Pointer<AVInputFormat.read_play_callback > read_play) {
		read_play(read_play);
		return read_play;
	}
	/**
	 * Pause playing - only meaningful if using a network-based format<br>
	 * (RTSP).<br>
	 * C type : read_pause_callback
	 */
	@Field(13) 
	public Pointer<AVInputFormat.read_pause_callback > read_pause() {
		return this.io.getPointerField(this, 13);
	}
	/**
	 * Pause playing - only meaningful if using a network-based format<br>
	 * (RTSP).<br>
	 * C type : read_pause_callback
	 */
	@Field(13) 
	public AVInputFormat read_pause(Pointer<AVInputFormat.read_pause_callback > read_pause) {
		this.io.setPointerField(this, 13, read_pause);
		return this;
	}
	/// C type : read_pause_callback
	public final Pointer<AVInputFormat.read_pause_callback > read_pause_$eq(Pointer<AVInputFormat.read_pause_callback > read_pause) {
		read_pause(read_pause);
		return read_pause;
	}
	/// C type : AVCodecTag**
	@Field(14) 
	public Pointer<Pointer<AVCodecTag > > codec_tag() {
		return this.io.getPointerField(this, 14);
	}
	/// C type : AVCodecTag**
	@Field(14) 
	public AVInputFormat codec_tag(Pointer<Pointer<AVCodecTag > > codec_tag) {
		this.io.setPointerField(this, 14, codec_tag);
		return this;
	}
	/// C type : AVCodecTag**
	public final Pointer<Pointer<AVCodecTag > > codec_tag_$eq(Pointer<Pointer<AVCodecTag > > codec_tag) {
		codec_tag(codec_tag);
		return codec_tag;
	}
	/**
	 * Seek to timestamp ts.<br>
	 * Seeking will be done so that the point from which all active streams<br>
	 * can be presented successfully will be closest to ts and within min/max_ts.<br>
	 * Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.<br>
	 * C type : read_seek2_callback
	 */
	@Field(15) 
	public Pointer<AVInputFormat.read_seek2_callback > read_seek2() {
		return this.io.getPointerField(this, 15);
	}
	/**
	 * Seek to timestamp ts.<br>
	 * Seeking will be done so that the point from which all active streams<br>
	 * can be presented successfully will be closest to ts and within min/max_ts.<br>
	 * Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.<br>
	 * C type : read_seek2_callback
	 */
	@Field(15) 
	public AVInputFormat read_seek2(Pointer<AVInputFormat.read_seek2_callback > read_seek2) {
		this.io.setPointerField(this, 15, read_seek2);
		return this;
	}
	/// C type : read_seek2_callback
	public final Pointer<AVInputFormat.read_seek2_callback > read_seek2_$eq(Pointer<AVInputFormat.read_seek2_callback > read_seek2) {
		read_seek2(read_seek2);
		return read_seek2;
	}
	/// C type : const AVMetadataConv*
	@Field(16) 
	public Pointer<AVMetadataConv > metadata_conv() {
		return this.io.getPointerField(this, 16);
	}
	/// C type : const AVMetadataConv*
	@Field(16) 
	public AVInputFormat metadata_conv(Pointer<AVMetadataConv > metadata_conv) {
		this.io.setPointerField(this, 16, metadata_conv);
		return this;
	}
	/// C type : const AVMetadataConv*
	public final Pointer<AVMetadataConv > metadata_conv_$eq(Pointer<AVMetadataConv > metadata_conv) {
		metadata_conv(metadata_conv);
		return metadata_conv;
	}
	/**
	 * private fields<br>
	 * C type : AVInputFormat*
	 */
	@Field(17) 
	public Pointer<AVInputFormat > next() {
		return this.io.getPointerField(this, 17);
	}
	/**
	 * private fields<br>
	 * C type : AVInputFormat*
	 */
	@Field(17) 
	public AVInputFormat next(Pointer<AVInputFormat > next) {
		this.io.setPointerField(this, 17, next);
		return this;
	}
	/// C type : AVInputFormat*
	public final Pointer<AVInputFormat > next_$eq(Pointer<AVInputFormat > next) {
		next(next);
		return next;
	}
	/// <i>native declaration : libavformat/avformat.h</i>
	public static abstract class read_probe_callback extends Callback<read_probe_callback > {
		public abstract int apply(Pointer<AVProbeData > AVProbeDataPtr1);
	};
	/// <i>native declaration : libavformat/avformat.h</i>
	public static abstract class read_header_callback extends Callback<read_header_callback > {
		public abstract int apply(Pointer<AVFormatContext > AVFormatContextPtr1, Pointer<AVFormatParameters > ap);
	};
	/// <i>native declaration : libavformat/avformat.h</i>
	public static abstract class read_packet_callback extends Callback<read_packet_callback > {
		public abstract int apply(Pointer<AVFormatContext > AVFormatContextPtr1, Pointer<AVPacket > pkt);
	};
	/// <i>native declaration : libavformat/avformat.h</i>
	public static abstract class read_close_callback extends Callback<read_close_callback > {
		public abstract int apply(Pointer<AVFormatContext > AVFormatContextPtr1);
	};
	/// <i>native declaration : libavformat/avformat.h</i>
	public static abstract class read_seek_callback extends Callback<read_seek_callback > {
		public abstract int apply(Pointer<AVFormatContext > AVFormatContextPtr1, int stream_index, long timestamp, int flags);
	};
	/// <i>native declaration : libavformat/avformat.h</i>
	public static abstract class read_timestamp_callback extends Callback<read_timestamp_callback > {
		public abstract long apply(Pointer<AVFormatContext > s, int stream_index, Pointer<Long > pos, long pos_limit);
	};
	/// <i>native declaration : libavformat/avformat.h</i>
	public static abstract class read_play_callback extends Callback<read_play_callback > {
		public abstract int apply(Pointer<AVFormatContext > AVFormatContextPtr1);
	};
	/// <i>native declaration : libavformat/avformat.h</i>
	public static abstract class read_pause_callback extends Callback<read_pause_callback > {
		public abstract int apply(Pointer<AVFormatContext > AVFormatContextPtr1);
	};
	/// <i>native declaration : libavformat/avformat.h</i>
	public static abstract class read_seek2_callback extends Callback<read_seek2_callback > {
		public abstract int apply(Pointer<AVFormatContext > s, int stream_index, long min_ts, long ts, long max_ts, int flags);
	};
}
