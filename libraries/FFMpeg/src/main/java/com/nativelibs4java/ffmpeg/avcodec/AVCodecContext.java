package com.nativelibs4java.ffmpeg.avcodec;
import com.nativelibs4java.ffmpeg.avutil.AVClass;
import com.nativelibs4java.ffmpeg.avutil.AVRational;
import com.nativelibs4java.ffmpeg.swscale.SwscaleLibrary.PixelFormat;
import org.bridj.Callback;
import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Array;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
/**
 * <i>native declaration : libavcodec/avcodec.h</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("avcodec") 
public class AVCodecContext extends StructObject {
	public AVCodecContext() {
		super();
	}
	public AVCodecContext(Pointer pointer) {
		super(pointer);
	}
	/**
	 * information on struct for av_log<br>
	 * - set by avcodec_alloc_context<br>
	 * C type : const AVClass*
	 */
	@Field(0) 
	public Pointer<AVClass > av_class() {
		return this.io.getPointerField(this, 0);
	}
	/**
	 * information on struct for av_log<br>
	 * - set by avcodec_alloc_context<br>
	 * C type : const AVClass*
	 */
	@Field(0) 
	public AVCodecContext av_class(Pointer<AVClass > av_class) {
		this.io.setPointerField(this, 0, av_class);
		return this;
	}
	/// C type : const AVClass*
	public final Pointer<AVClass > av_class_$eq(Pointer<AVClass > av_class) {
		av_class(av_class);
		return av_class;
	}
	/**
	 * the average bitrate<br>
	 * - encoding: Set by user; unused for constant quantizer encoding.<br>
	 * - decoding: Set by libavcodec. 0 or some bitrate if this info is available in the stream.
	 */
	@Field(1) 
	public int bit_rate() {
		return this.io.getIntField(this, 1);
	}
	/**
	 * the average bitrate<br>
	 * - encoding: Set by user; unused for constant quantizer encoding.<br>
	 * - decoding: Set by libavcodec. 0 or some bitrate if this info is available in the stream.
	 */
	@Field(1) 
	public AVCodecContext bit_rate(int bit_rate) {
		this.io.setIntField(this, 1, bit_rate);
		return this;
	}
	public final int bit_rate_$eq(int bit_rate) {
		bit_rate(bit_rate);
		return bit_rate;
	}
	/**
	 * number of bits the bitstream is allowed to diverge from the reference.<br>
	 *           the reference can be CBR (for CBR pass1) or VBR (for pass2)<br>
	 * - encoding: Set by user; unused for constant quantizer encoding.<br>
	 * - decoding: unused
	 */
	@Field(2) 
	public int bit_rate_tolerance() {
		return this.io.getIntField(this, 2);
	}
	/**
	 * number of bits the bitstream is allowed to diverge from the reference.<br>
	 *           the reference can be CBR (for CBR pass1) or VBR (for pass2)<br>
	 * - encoding: Set by user; unused for constant quantizer encoding.<br>
	 * - decoding: unused
	 */
	@Field(2) 
	public AVCodecContext bit_rate_tolerance(int bit_rate_tolerance) {
		this.io.setIntField(this, 2, bit_rate_tolerance);
		return this;
	}
	public final int bit_rate_tolerance_$eq(int bit_rate_tolerance) {
		bit_rate_tolerance(bit_rate_tolerance);
		return bit_rate_tolerance;
	}
	/**
	 * CODEC_FLAG_*.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.
	 */
	@Field(3) 
	public int flags() {
		return this.io.getIntField(this, 3);
	}
	/**
	 * CODEC_FLAG_*.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.
	 */
	@Field(3) 
	public AVCodecContext flags(int flags) {
		this.io.setIntField(this, 3, flags);
		return this;
	}
	public final int flags_$eq(int flags) {
		flags(flags);
		return flags;
	}
	/**
	 * Some codecs need additional format info. It is stored here.<br>
	 * If any muxer uses this then ALL demuxers/parsers AND encoders for the<br>
	 * specific codec MUST set it correctly otherwise stream copy breaks.<br>
	 * In general use of this field by muxers is not recommanded.<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: Set by libavcodec. (FIXME: Is this OK?)
	 */
	@Field(4) 
	public int sub_id() {
		return this.io.getIntField(this, 4);
	}
	/**
	 * Some codecs need additional format info. It is stored here.<br>
	 * If any muxer uses this then ALL demuxers/parsers AND encoders for the<br>
	 * specific codec MUST set it correctly otherwise stream copy breaks.<br>
	 * In general use of this field by muxers is not recommanded.<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: Set by libavcodec. (FIXME: Is this OK?)
	 */
	@Field(4) 
	public AVCodecContext sub_id(int sub_id) {
		this.io.setIntField(this, 4, sub_id);
		return this;
	}
	public final int sub_id_$eq(int sub_id) {
		sub_id(sub_id);
		return sub_id;
	}
	/**
	 * Motion estimation algorithm used for video coding.<br>
	 * 1 (zero), 2 (full), 3 (log), 4 (phods), 5 (epzs), 6 (x1), 7 (hex),<br>
	 * 8 (umh), 9 (iter), 10 (tesa) [7, 8, 10 are x264 specific, 9 is snow specific]<br>
	 * - encoding: MUST be set by user.<br>
	 * - decoding: unused
	 */
	@Field(5) 
	public int me_method() {
		return this.io.getIntField(this, 5);
	}
	/**
	 * Motion estimation algorithm used for video coding.<br>
	 * 1 (zero), 2 (full), 3 (log), 4 (phods), 5 (epzs), 6 (x1), 7 (hex),<br>
	 * 8 (umh), 9 (iter), 10 (tesa) [7, 8, 10 are x264 specific, 9 is snow specific]<br>
	 * - encoding: MUST be set by user.<br>
	 * - decoding: unused
	 */
	@Field(5) 
	public AVCodecContext me_method(int me_method) {
		this.io.setIntField(this, 5, me_method);
		return this;
	}
	public final int me_method_$eq(int me_method) {
		me_method(me_method);
		return me_method;
	}
	/**
	 * some codecs need / can use extradata like Huffman tables.<br>
	 * mjpeg: Huffman tables<br>
	 * rv10: additional flags<br>
	 * mpeg4: global headers (they can be in the bitstream or here)<br>
	 * The allocated memory should be FF_INPUT_BUFFER_PADDING_SIZE bytes larger<br>
	 * than extradata_size to avoid prolems if it is read with the bitstream reader.<br>
	 * The bytewise contents of extradata must not depend on the architecture or CPU endianness.<br>
	 * - encoding: Set/allocated/freed by libavcodec.<br>
	 * - decoding: Set/allocated/freed by user.<br>
	 * C type : uint8_t*
	 */
	@Field(6) 
	public Pointer<Byte > extradata() {
		return this.io.getPointerField(this, 6);
	}
	/**
	 * some codecs need / can use extradata like Huffman tables.<br>
	 * mjpeg: Huffman tables<br>
	 * rv10: additional flags<br>
	 * mpeg4: global headers (they can be in the bitstream or here)<br>
	 * The allocated memory should be FF_INPUT_BUFFER_PADDING_SIZE bytes larger<br>
	 * than extradata_size to avoid prolems if it is read with the bitstream reader.<br>
	 * The bytewise contents of extradata must not depend on the architecture or CPU endianness.<br>
	 * - encoding: Set/allocated/freed by libavcodec.<br>
	 * - decoding: Set/allocated/freed by user.<br>
	 * C type : uint8_t*
	 */
	@Field(6) 
	public AVCodecContext extradata(Pointer<Byte > extradata) {
		this.io.setPointerField(this, 6, extradata);
		return this;
	}
	/// C type : uint8_t*
	public final Pointer<Byte > extradata_$eq(Pointer<Byte > extradata) {
		extradata(extradata);
		return extradata;
	}
	@Field(7) 
	public int extradata_size() {
		return this.io.getIntField(this, 7);
	}
	@Field(7) 
	public AVCodecContext extradata_size(int extradata_size) {
		this.io.setIntField(this, 7, extradata_size);
		return this;
	}
	public final int extradata_size_$eq(int extradata_size) {
		extradata_size(extradata_size);
		return extradata_size;
	}
	/**
	 * This is the fundamental unit of time (in seconds) in terms<br>
	 * of which frame timestamps are represented. For fixed-fps content,<br>
	 * timebase should be 1/framerate and timestamp increments should be<br>
	 * identically 1.<br>
	 * - encoding: MUST be set by user.<br>
	 * - decoding: Set by libavcodec.<br>
	 * C type : AVRational
	 */
	@Field(8) 
	public AVRational time_base() {
		return this.io.getNativeObjectField(this, 8);
	}
	/**
	 * picture width / height.<br>
	 * - encoding: MUST be set by user.<br>
	 * - decoding: Set by libavcodec.<br>
	 * Note: For compatibility it is possible to set this instead of<br>
	 * coded_width/height before decoding.
	 */
	@Field(9) 
	public int width() {
		return this.io.getIntField(this, 9);
	}
	/**
	 * picture width / height.<br>
	 * - encoding: MUST be set by user.<br>
	 * - decoding: Set by libavcodec.<br>
	 * Note: For compatibility it is possible to set this instead of<br>
	 * coded_width/height before decoding.
	 */
	@Field(9) 
	public AVCodecContext width(int width) {
		this.io.setIntField(this, 9, width);
		return this;
	}
	public final int width_$eq(int width) {
		width(width);
		return width;
	}
	/**
	 * picture width / height.<br>
	 * - encoding: MUST be set by user.<br>
	 * - decoding: Set by libavcodec.<br>
	 * Note: For compatibility it is possible to set this instead of<br>
	 * coded_width/height before decoding.
	 */
	@Field(10) 
	public int height() {
		return this.io.getIntField(this, 10);
	}
	/**
	 * picture width / height.<br>
	 * - encoding: MUST be set by user.<br>
	 * - decoding: Set by libavcodec.<br>
	 * Note: For compatibility it is possible to set this instead of<br>
	 * coded_width/height before decoding.
	 */
	@Field(10) 
	public AVCodecContext height(int height) {
		this.io.setIntField(this, 10, height);
		return this;
	}
	public final int height_$eq(int height) {
		height(height);
		return height;
	}
	/**
	 * the number of pictures in a group of pictures, or 0 for intra_only<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(11) 
	public int gop_size() {
		return this.io.getIntField(this, 11);
	}
	/**
	 * the number of pictures in a group of pictures, or 0 for intra_only<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(11) 
	public AVCodecContext gop_size(int gop_size) {
		this.io.setIntField(this, 11, gop_size);
		return this;
	}
	public final int gop_size_$eq(int gop_size) {
		gop_size(gop_size);
		return gop_size;
	}
	/**
	 * Frame rate emulation. If not zero, the lower layer (i.e. format handler)<br>
	 * has to read frames at native frame rate.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(13) 
	public int rate_emu() {
		return this.io.getIntField(this, 13);
	}
	/**
	 * Frame rate emulation. If not zero, the lower layer (i.e. format handler)<br>
	 * has to read frames at native frame rate.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(13) 
	public AVCodecContext rate_emu(int rate_emu) {
		this.io.setIntField(this, 13, rate_emu);
		return this;
	}
	public final int rate_emu_$eq(int rate_emu) {
		rate_emu(rate_emu);
		return rate_emu;
	}
	/**
	 * If non NULL, 'draw_horiz_band' is called by the libavcodec<br>
	 * decoder to draw a horizontal band. It improves cache usage. Not<br>
	 * all codecs can do that. You must check the codec capabilities<br>
	 * beforehand.<br>
	 * The function is also used by hardware acceleration APIs.<br>
	 * It is called at least once during frame decoding to pass<br>
	 * the data needed for hardware render.<br>
	 * In that mode instead of pixel data, AVFrame points to<br>
	 * a structure specific to the acceleration API. The application<br>
	 * reads the structure and can change some fields to indicate progress<br>
	 * or mark state.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.<br>
	 * @param height the height of the slice<br>
	 * @param y the y position of the slice<br>
	 * @param type 1->top field, 2->bottom field, 3->frame<br>
	 * @param offset offset into the AVFrame.data from which the slice should be read<br>
	 * C type : draw_horiz_band_callback
	 */
	@Field(14) 
	public Pointer<AVCodecContext.draw_horiz_band_callback > draw_horiz_band() {
		return this.io.getPointerField(this, 14);
	}
	/**
	 * If non NULL, 'draw_horiz_band' is called by the libavcodec<br>
	 * decoder to draw a horizontal band. It improves cache usage. Not<br>
	 * all codecs can do that. You must check the codec capabilities<br>
	 * beforehand.<br>
	 * The function is also used by hardware acceleration APIs.<br>
	 * It is called at least once during frame decoding to pass<br>
	 * the data needed for hardware render.<br>
	 * In that mode instead of pixel data, AVFrame points to<br>
	 * a structure specific to the acceleration API. The application<br>
	 * reads the structure and can change some fields to indicate progress<br>
	 * or mark state.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.<br>
	 * @param height the height of the slice<br>
	 * @param y the y position of the slice<br>
	 * @param type 1->top field, 2->bottom field, 3->frame<br>
	 * @param offset offset into the AVFrame.data from which the slice should be read<br>
	 * C type : draw_horiz_band_callback
	 */
	@Field(14) 
	public AVCodecContext draw_horiz_band(Pointer<AVCodecContext.draw_horiz_band_callback > draw_horiz_band) {
		this.io.setPointerField(this, 14, draw_horiz_band);
		return this;
	}
	/// C type : draw_horiz_band_callback
	public final Pointer<AVCodecContext.draw_horiz_band_callback > draw_horiz_band_$eq(Pointer<AVCodecContext.draw_horiz_band_callback > draw_horiz_band) {
		draw_horiz_band(draw_horiz_band);
		return draw_horiz_band;
	}
	/**
	 * audio only<br>
	 * < samples per second
	 */
	@Field(15) 
	public int sample_rate() {
		return this.io.getIntField(this, 15);
	}
	/**
	 * audio only<br>
	 * < samples per second
	 */
	@Field(15) 
	public AVCodecContext sample_rate(int sample_rate) {
		this.io.setIntField(this, 15, sample_rate);
		return this;
	}
	public final int sample_rate_$eq(int sample_rate) {
		sample_rate(sample_rate);
		return sample_rate;
	}
	/// < number of audio channels
	@Field(16) 
	public int channels() {
		return this.io.getIntField(this, 16);
	}
	/// < number of audio channels
	@Field(16) 
	public AVCodecContext channels(int channels) {
		this.io.setIntField(this, 16, channels);
		return this;
	}
	public final int channels_$eq(int channels) {
		channels(channels);
		return channels;
	}
	/// Samples per packet, initialized when calling 'init'.
	@Field(18) 
	public int frame_size() {
		return this.io.getIntField(this, 18);
	}
	/// Samples per packet, initialized when calling 'init'.
	@Field(18) 
	public AVCodecContext frame_size(int frame_size) {
		this.io.setIntField(this, 18, frame_size);
		return this;
	}
	public final int frame_size_$eq(int frame_size) {
		frame_size(frame_size);
		return frame_size;
	}
	/// < audio or video frame number
	@Field(19) 
	public int frame_number() {
		return this.io.getIntField(this, 19);
	}
	/// < audio or video frame number
	@Field(19) 
	public AVCodecContext frame_number(int frame_number) {
		this.io.setIntField(this, 19, frame_number);
		return this;
	}
	public final int frame_number_$eq(int frame_number) {
		frame_number(frame_number);
		return frame_number;
	}
	/// < Returns the real picture number of previous encoded frame.
	@Field(20) 
	public int real_pict_num() {
		return this.io.getIntField(this, 20);
	}
	/// < Returns the real picture number of previous encoded frame.
	@Field(20) 
	public AVCodecContext real_pict_num(int real_pict_num) {
		this.io.setIntField(this, 20, real_pict_num);
		return this;
	}
	public final int real_pict_num_$eq(int real_pict_num) {
		real_pict_num(real_pict_num);
		return real_pict_num;
	}
	/**
	 * Number of frames the decoded output will be delayed relative to<br>
	 * the encoded input.<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: unused
	 */
	@Field(21) 
	public int delay() {
		return this.io.getIntField(this, 21);
	}
	/**
	 * Number of frames the decoded output will be delayed relative to<br>
	 * the encoded input.<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: unused
	 */
	@Field(21) 
	public AVCodecContext delay(int delay) {
		this.io.setIntField(this, 21, delay);
		return this;
	}
	public final int delay_$eq(int delay) {
		delay(delay);
		return delay;
	}
	/**
	 * - encoding parameters<br>
	 * < amount of qscale change between easy & hard scenes (0.0-1.0)
	 */
	@Field(22) 
	public float qcompress() {
		return this.io.getFloatField(this, 22);
	}
	/**
	 * - encoding parameters<br>
	 * < amount of qscale change between easy & hard scenes (0.0-1.0)
	 */
	@Field(22) 
	public AVCodecContext qcompress(float qcompress) {
		this.io.setFloatField(this, 22, qcompress);
		return this;
	}
	public final float qcompress_$eq(float qcompress) {
		qcompress(qcompress);
		return qcompress;
	}
	/// < amount of qscale smoothing over time (0.0-1.0)
	@Field(23) 
	public float qblur() {
		return this.io.getFloatField(this, 23);
	}
	/// < amount of qscale smoothing over time (0.0-1.0)
	@Field(23) 
	public AVCodecContext qblur(float qblur) {
		this.io.setFloatField(this, 23, qblur);
		return this;
	}
	public final float qblur_$eq(float qblur) {
		qblur(qblur);
		return qblur;
	}
	/**
	 * minimum quantizer<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(24) 
	public int qmin() {
		return this.io.getIntField(this, 24);
	}
	/**
	 * minimum quantizer<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(24) 
	public AVCodecContext qmin(int qmin) {
		this.io.setIntField(this, 24, qmin);
		return this;
	}
	public final int qmin_$eq(int qmin) {
		qmin(qmin);
		return qmin;
	}
	/**
	 * maximum quantizer<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(25) 
	public int qmax() {
		return this.io.getIntField(this, 25);
	}
	/**
	 * maximum quantizer<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(25) 
	public AVCodecContext qmax(int qmax) {
		this.io.setIntField(this, 25, qmax);
		return this;
	}
	public final int qmax_$eq(int qmax) {
		qmax(qmax);
		return qmax;
	}
	/**
	 * maximum quantizer difference between frames<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(26) 
	public int max_qdiff() {
		return this.io.getIntField(this, 26);
	}
	/**
	 * maximum quantizer difference between frames<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(26) 
	public AVCodecContext max_qdiff(int max_qdiff) {
		this.io.setIntField(this, 26, max_qdiff);
		return this;
	}
	public final int max_qdiff_$eq(int max_qdiff) {
		max_qdiff(max_qdiff);
		return max_qdiff;
	}
	/**
	 * maximum number of B-frames between non-B-frames<br>
	 * Note: The output will be delayed by max_b_frames+1 relative to the input.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(27) 
	public int max_b_frames() {
		return this.io.getIntField(this, 27);
	}
	/**
	 * maximum number of B-frames between non-B-frames<br>
	 * Note: The output will be delayed by max_b_frames+1 relative to the input.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(27) 
	public AVCodecContext max_b_frames(int max_b_frames) {
		this.io.setIntField(this, 27, max_b_frames);
		return this;
	}
	public final int max_b_frames_$eq(int max_b_frames) {
		max_b_frames(max_b_frames);
		return max_b_frames;
	}
	/**
	 * qscale factor between IP and B-frames<br>
	 * If > 0 then the last P-frame quantizer will be used (q= lastp_q*factor+offset).<br>
	 * If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(28) 
	public float b_quant_factor() {
		return this.io.getFloatField(this, 28);
	}
	/**
	 * qscale factor between IP and B-frames<br>
	 * If > 0 then the last P-frame quantizer will be used (q= lastp_q*factor+offset).<br>
	 * If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(28) 
	public AVCodecContext b_quant_factor(float b_quant_factor) {
		this.io.setFloatField(this, 28, b_quant_factor);
		return this;
	}
	public final float b_quant_factor_$eq(float b_quant_factor) {
		b_quant_factor(b_quant_factor);
		return b_quant_factor;
	}
	/// obsolete FIXME remove
	@Field(29) 
	public int rc_strategy() {
		return this.io.getIntField(this, 29);
	}
	/// obsolete FIXME remove
	@Field(29) 
	public AVCodecContext rc_strategy(int rc_strategy) {
		this.io.setIntField(this, 29, rc_strategy);
		return this;
	}
	public final int rc_strategy_$eq(int rc_strategy) {
		rc_strategy(rc_strategy);
		return rc_strategy;
	}
	@Field(30) 
	public int b_frame_strategy() {
		return this.io.getIntField(this, 30);
	}
	@Field(30) 
	public AVCodecContext b_frame_strategy(int b_frame_strategy) {
		this.io.setIntField(this, 30, b_frame_strategy);
		return this;
	}
	public final int b_frame_strategy_$eq(int b_frame_strategy) {
		b_frame_strategy(b_frame_strategy);
		return b_frame_strategy;
	}
	/**
	 * hurry up amount<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user. 1-> Skip B-frames, 2-> Skip IDCT/dequant too, 5-> Skip everything except header<br>
	 * @deprecated Deprecated in favor of skip_idct and skip_frame.
	 */
	@Field(31) 
	public int hurry_up() {
		return this.io.getIntField(this, 31);
	}
	/**
	 * hurry up amount<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user. 1-> Skip B-frames, 2-> Skip IDCT/dequant too, 5-> Skip everything except header<br>
	 * @deprecated Deprecated in favor of skip_idct and skip_frame.
	 */
	@Field(31) 
	public AVCodecContext hurry_up(int hurry_up) {
		this.io.setIntField(this, 31, hurry_up);
		return this;
	}
	public final int hurry_up_$eq(int hurry_up) {
		hurry_up(hurry_up);
		return hurry_up;
	}
	/// C type : AVCodec*
	@Field(32) 
	public Pointer<AVCodec > codec() {
		return this.io.getPointerField(this, 32);
	}
	/// C type : AVCodec*
	@Field(32) 
	public AVCodecContext codec(Pointer<AVCodec > codec) {
		this.io.setPointerField(this, 32, codec);
		return this;
	}
	/// C type : AVCodec*
	public final Pointer<AVCodec > codec_$eq(Pointer<AVCodec > codec) {
		codec(codec);
		return codec;
	}
	/// C type : void*
	@Field(33) 
	public Pointer<? > priv_data() {
		return this.io.getPointerField(this, 33);
	}
	/// C type : void*
	@Field(33) 
	public AVCodecContext priv_data(Pointer<? > priv_data) {
		this.io.setPointerField(this, 33, priv_data);
		return this;
	}
	/// C type : void*
	public final Pointer<? > priv_data_$eq(Pointer<? > priv_data) {
		priv_data(priv_data);
		return priv_data;
	}
	/// The size of the RTP payload: the coder will
	@Field(34) 
	public int rtp_payload_size() {
		return this.io.getIntField(this, 34);
	}
	/// The size of the RTP payload: the coder will
	@Field(34) 
	public AVCodecContext rtp_payload_size(int rtp_payload_size) {
		this.io.setIntField(this, 34, rtp_payload_size);
		return this;
	}
	public final int rtp_payload_size_$eq(int rtp_payload_size) {
		rtp_payload_size(rtp_payload_size);
		return rtp_payload_size;
	}
	/**
	 * encoded in the RTP payload.<br>
	 * C type : rtp_callback_callback
	 */
	@Field(35) 
	public Pointer<AVCodecContext.rtp_callback_callback > rtp_callback() {
		return this.io.getPointerField(this, 35);
	}
	/**
	 * encoded in the RTP payload.<br>
	 * C type : rtp_callback_callback
	 */
	@Field(35) 
	public AVCodecContext rtp_callback(Pointer<AVCodecContext.rtp_callback_callback > rtp_callback) {
		this.io.setPointerField(this, 35, rtp_callback);
		return this;
	}
	/// C type : rtp_callback_callback
	public final Pointer<AVCodecContext.rtp_callback_callback > rtp_callback_$eq(Pointer<AVCodecContext.rtp_callback_callback > rtp_callback) {
		rtp_callback(rtp_callback);
		return rtp_callback;
	}
	/// statistics, used for 2-pass encoding
	@Field(36) 
	public int mv_bits() {
		return this.io.getIntField(this, 36);
	}
	/// statistics, used for 2-pass encoding
	@Field(36) 
	public AVCodecContext mv_bits(int mv_bits) {
		this.io.setIntField(this, 36, mv_bits);
		return this;
	}
	public final int mv_bits_$eq(int mv_bits) {
		mv_bits(mv_bits);
		return mv_bits;
	}
	@Field(37) 
	public int header_bits() {
		return this.io.getIntField(this, 37);
	}
	@Field(37) 
	public AVCodecContext header_bits(int header_bits) {
		this.io.setIntField(this, 37, header_bits);
		return this;
	}
	public final int header_bits_$eq(int header_bits) {
		header_bits(header_bits);
		return header_bits;
	}
	@Field(38) 
	public int i_tex_bits() {
		return this.io.getIntField(this, 38);
	}
	@Field(38) 
	public AVCodecContext i_tex_bits(int i_tex_bits) {
		this.io.setIntField(this, 38, i_tex_bits);
		return this;
	}
	public final int i_tex_bits_$eq(int i_tex_bits) {
		i_tex_bits(i_tex_bits);
		return i_tex_bits;
	}
	@Field(39) 
	public int p_tex_bits() {
		return this.io.getIntField(this, 39);
	}
	@Field(39) 
	public AVCodecContext p_tex_bits(int p_tex_bits) {
		this.io.setIntField(this, 39, p_tex_bits);
		return this;
	}
	public final int p_tex_bits_$eq(int p_tex_bits) {
		p_tex_bits(p_tex_bits);
		return p_tex_bits;
	}
	@Field(40) 
	public int i_count() {
		return this.io.getIntField(this, 40);
	}
	@Field(40) 
	public AVCodecContext i_count(int i_count) {
		this.io.setIntField(this, 40, i_count);
		return this;
	}
	public final int i_count_$eq(int i_count) {
		i_count(i_count);
		return i_count;
	}
	@Field(41) 
	public int p_count() {
		return this.io.getIntField(this, 41);
	}
	@Field(41) 
	public AVCodecContext p_count(int p_count) {
		this.io.setIntField(this, 41, p_count);
		return this;
	}
	public final int p_count_$eq(int p_count) {
		p_count(p_count);
		return p_count;
	}
	@Field(42) 
	public int skip_count() {
		return this.io.getIntField(this, 42);
	}
	@Field(42) 
	public AVCodecContext skip_count(int skip_count) {
		this.io.setIntField(this, 42, skip_count);
		return this;
	}
	public final int skip_count_$eq(int skip_count) {
		skip_count(skip_count);
		return skip_count;
	}
	@Field(43) 
	public int misc_bits() {
		return this.io.getIntField(this, 43);
	}
	@Field(43) 
	public AVCodecContext misc_bits(int misc_bits) {
		this.io.setIntField(this, 43, misc_bits);
		return this;
	}
	public final int misc_bits_$eq(int misc_bits) {
		misc_bits(misc_bits);
		return misc_bits;
	}
	/**
	 * number of bits used for the previously encoded frame<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: unused
	 */
	@Field(44) 
	public int frame_bits() {
		return this.io.getIntField(this, 44);
	}
	/**
	 * number of bits used for the previously encoded frame<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: unused
	 */
	@Field(44) 
	public AVCodecContext frame_bits(int frame_bits) {
		this.io.setIntField(this, 44, frame_bits);
		return this;
	}
	public final int frame_bits_$eq(int frame_bits) {
		frame_bits(frame_bits);
		return frame_bits;
	}
	/**
	 * Private data of the user, can be used to carry app specific stuff.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.<br>
	 * C type : void*
	 */
	@Field(45) 
	public Pointer<? > opaque() {
		return this.io.getPointerField(this, 45);
	}
	/**
	 * Private data of the user, can be used to carry app specific stuff.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.<br>
	 * C type : void*
	 */
	@Field(45) 
	public AVCodecContext opaque(Pointer<? > opaque) {
		this.io.setPointerField(this, 45, opaque);
		return this;
	}
	/// C type : void*
	public final Pointer<? > opaque_$eq(Pointer<? > opaque) {
		opaque(opaque);
		return opaque;
	}
	/// C type : char[32]
	@Array({32}) 
	@Field(46) 
	public Pointer<Byte > codec_name() {
		return this.io.getPointerField(this, 46);
	}
	/**
	 * fourcc (LSB first, so "ABCD" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').<br>
	 * This is used to work around some encoder bugs.<br>
	 * A demuxer should set this to what is stored in the field used to identify the codec.<br>
	 * If there are multiple such fields in a container then the demuxer should choose the one<br>
	 * which maximizes the information about the used codec.<br>
	 * If the codec tag field in a container is larger then 32 bits then the demuxer should<br>
	 * remap the longer ID to 32 bits with a table or other structure. Alternatively a new<br>
	 * extra_codec_tag + size could be added but for this a clear advantage must be demonstrated<br>
	 * first.<br>
	 * - encoding: Set by user, if not then the default based on codec_id will be used.<br>
	 * - decoding: Set by user, will be converted to uppercase by libavcodec during init.
	 */
	@Field(49) 
	public int codec_tag() {
		return this.io.getIntField(this, 49);
	}
	/**
	 * fourcc (LSB first, so "ABCD" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').<br>
	 * This is used to work around some encoder bugs.<br>
	 * A demuxer should set this to what is stored in the field used to identify the codec.<br>
	 * If there are multiple such fields in a container then the demuxer should choose the one<br>
	 * which maximizes the information about the used codec.<br>
	 * If the codec tag field in a container is larger then 32 bits then the demuxer should<br>
	 * remap the longer ID to 32 bits with a table or other structure. Alternatively a new<br>
	 * extra_codec_tag + size could be added but for this a clear advantage must be demonstrated<br>
	 * first.<br>
	 * - encoding: Set by user, if not then the default based on codec_id will be used.<br>
	 * - decoding: Set by user, will be converted to uppercase by libavcodec during init.
	 */
	@Field(49) 
	public AVCodecContext codec_tag(int codec_tag) {
		this.io.setIntField(this, 49, codec_tag);
		return this;
	}
	public final int codec_tag_$eq(int codec_tag) {
		codec_tag(codec_tag);
		return codec_tag;
	}
	/**
	 * Work around bugs in encoders which sometimes cannot be detected automatically.<br>
	 * - encoding: Set by user<br>
	 * - decoding: Set by user
	 */
	@Field(50) 
	public int workaround_bugs() {
		return this.io.getIntField(this, 50);
	}
	/**
	 * Work around bugs in encoders which sometimes cannot be detected automatically.<br>
	 * - encoding: Set by user<br>
	 * - decoding: Set by user
	 */
	@Field(50) 
	public AVCodecContext workaround_bugs(int workaround_bugs) {
		this.io.setIntField(this, 50, workaround_bugs);
		return this;
	}
	public final int workaround_bugs_$eq(int workaround_bugs) {
		workaround_bugs(workaround_bugs);
		return workaround_bugs;
	}
	/**
	 * luma single coefficient elimination threshold<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(51) 
	public int luma_elim_threshold() {
		return this.io.getIntField(this, 51);
	}
	/**
	 * luma single coefficient elimination threshold<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(51) 
	public AVCodecContext luma_elim_threshold(int luma_elim_threshold) {
		this.io.setIntField(this, 51, luma_elim_threshold);
		return this;
	}
	public final int luma_elim_threshold_$eq(int luma_elim_threshold) {
		luma_elim_threshold(luma_elim_threshold);
		return luma_elim_threshold;
	}
	/**
	 * chroma single coeff elimination threshold<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(52) 
	public int chroma_elim_threshold() {
		return this.io.getIntField(this, 52);
	}
	/**
	 * chroma single coeff elimination threshold<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(52) 
	public AVCodecContext chroma_elim_threshold(int chroma_elim_threshold) {
		this.io.setIntField(this, 52, chroma_elim_threshold);
		return this;
	}
	public final int chroma_elim_threshold_$eq(int chroma_elim_threshold) {
		chroma_elim_threshold(chroma_elim_threshold);
		return chroma_elim_threshold;
	}
	/**
	 * strictly follow the standard (MPEG4, ...).<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.<br>
	 * Setting this to STRICT or higher means the encoder and decoder will<br>
	 * generally do stupid things, whereas setting it to unofficial or lower<br>
	 * will mean the encoder might produce output that is not supported by all<br>
	 * spec-compliant decoders. Decoders don't differentiate between normal,<br>
	 * unofficial and experimental (that is, they always try to decode things<br>
	 * when they can) unless they are explicitly asked to behave stupidly<br>
	 * (=strictly conform to the specs)
	 */
	@Field(53) 
	public int strict_std_compliance() {
		return this.io.getIntField(this, 53);
	}
	/**
	 * strictly follow the standard (MPEG4, ...).<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.<br>
	 * Setting this to STRICT or higher means the encoder and decoder will<br>
	 * generally do stupid things, whereas setting it to unofficial or lower<br>
	 * will mean the encoder might produce output that is not supported by all<br>
	 * spec-compliant decoders. Decoders don't differentiate between normal,<br>
	 * unofficial and experimental (that is, they always try to decode things<br>
	 * when they can) unless they are explicitly asked to behave stupidly<br>
	 * (=strictly conform to the specs)
	 */
	@Field(53) 
	public AVCodecContext strict_std_compliance(int strict_std_compliance) {
		this.io.setIntField(this, 53, strict_std_compliance);
		return this;
	}
	public final int strict_std_compliance_$eq(int strict_std_compliance) {
		strict_std_compliance(strict_std_compliance);
		return strict_std_compliance;
	}
	/**
	 * qscale offset between IP and B-frames<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(54) 
	public float b_quant_offset() {
		return this.io.getFloatField(this, 54);
	}
	/**
	 * qscale offset between IP and B-frames<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(54) 
	public AVCodecContext b_quant_offset(float b_quant_offset) {
		this.io.setFloatField(this, 54, b_quant_offset);
		return this;
	}
	public final float b_quant_offset_$eq(float b_quant_offset) {
		b_quant_offset(b_quant_offset);
		return b_quant_offset;
	}
	/**
	 * Error recognization; higher values will detect more errors but may<br>
	 * misdetect some more or less valid parts as errors.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	@Field(55) 
	public int error_recognition() {
		return this.io.getIntField(this, 55);
	}
	/**
	 * Error recognization; higher values will detect more errors but may<br>
	 * misdetect some more or less valid parts as errors.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	@Field(55) 
	public AVCodecContext error_recognition(int error_recognition) {
		this.io.setIntField(this, 55, error_recognition);
		return this;
	}
	public final int error_recognition_$eq(int error_recognition) {
		error_recognition(error_recognition);
		return error_recognition;
	}
	/**
	 * Called at the beginning of each frame to get a buffer for it.<br>
	 * If pic.reference is set then the frame will be read later by libavcodec.<br>
	 * avcodec_align_dimensions2() should be used to find the required width and<br>
	 * height, as they normally need to be rounded up to the next multiple of 16.<br>
	 * if CODEC_CAP_DR1 is not set then get_buffer() must call<br>
	 * avcodec_default_get_buffer() instead of providing buffers allocated by<br>
	 * some other means.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by libavcodec, user can override.<br>
	 * C type : get_buffer_callback
	 */
	@Field(56) 
	public Pointer<AVCodecContext.get_buffer_callback > get_buffer() {
		return this.io.getPointerField(this, 56);
	}
	/**
	 * Called at the beginning of each frame to get a buffer for it.<br>
	 * If pic.reference is set then the frame will be read later by libavcodec.<br>
	 * avcodec_align_dimensions2() should be used to find the required width and<br>
	 * height, as they normally need to be rounded up to the next multiple of 16.<br>
	 * if CODEC_CAP_DR1 is not set then get_buffer() must call<br>
	 * avcodec_default_get_buffer() instead of providing buffers allocated by<br>
	 * some other means.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by libavcodec, user can override.<br>
	 * C type : get_buffer_callback
	 */
	@Field(56) 
	public AVCodecContext get_buffer(Pointer<AVCodecContext.get_buffer_callback > get_buffer) {
		this.io.setPointerField(this, 56, get_buffer);
		return this;
	}
	/// C type : get_buffer_callback
	public final Pointer<AVCodecContext.get_buffer_callback > get_buffer_$eq(Pointer<AVCodecContext.get_buffer_callback > get_buffer) {
		get_buffer(get_buffer);
		return get_buffer;
	}
	/**
	 * Called to release buffers which were allocated with get_buffer.<br>
	 * A released buffer can be reused in get_buffer().<br>
	 * pic.data[*] must be set to NULL.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by libavcodec, user can override.<br>
	 * C type : release_buffer_callback
	 */
	@Field(57) 
	public Pointer<AVCodecContext.release_buffer_callback > release_buffer() {
		return this.io.getPointerField(this, 57);
	}
	/**
	 * Called to release buffers which were allocated with get_buffer.<br>
	 * A released buffer can be reused in get_buffer().<br>
	 * pic.data[*] must be set to NULL.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by libavcodec, user can override.<br>
	 * C type : release_buffer_callback
	 */
	@Field(57) 
	public AVCodecContext release_buffer(Pointer<AVCodecContext.release_buffer_callback > release_buffer) {
		this.io.setPointerField(this, 57, release_buffer);
		return this;
	}
	/// C type : release_buffer_callback
	public final Pointer<AVCodecContext.release_buffer_callback > release_buffer_$eq(Pointer<AVCodecContext.release_buffer_callback > release_buffer) {
		release_buffer(release_buffer);
		return release_buffer;
	}
	/**
	 * Size of the frame reordering buffer in the decoder.<br>
	 * For MPEG-2 it is 1 IPB or 0 low delay IP.<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: Set by libavcodec.
	 */
	@Field(58) 
	public int has_b_frames() {
		return this.io.getIntField(this, 58);
	}
	/**
	 * Size of the frame reordering buffer in the decoder.<br>
	 * For MPEG-2 it is 1 IPB or 0 low delay IP.<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: Set by libavcodec.
	 */
	@Field(58) 
	public AVCodecContext has_b_frames(int has_b_frames) {
		this.io.setIntField(this, 58, has_b_frames);
		return this;
	}
	public final int has_b_frames_$eq(int has_b_frames) {
		has_b_frames(has_b_frames);
		return has_b_frames;
	}
	/**
	 * number of bytes per packet if constant and known or 0<br>
	 * Used by some WAV based audio codecs.
	 */
	@Field(59) 
	public int block_align() {
		return this.io.getIntField(this, 59);
	}
	/**
	 * number of bytes per packet if constant and known or 0<br>
	 * Used by some WAV based audio codecs.
	 */
	@Field(59) 
	public AVCodecContext block_align(int block_align) {
		this.io.setIntField(this, 59, block_align);
		return this;
	}
	public final int block_align_$eq(int block_align) {
		block_align(block_align);
		return block_align;
	}
	/**
	 * - decoding only: If true, only parsing is done<br>
	 * (function avcodec_parse_frame()). The frame<br>
	 * data is returned. Only MPEG codecs support this now.
	 */
	@Field(60) 
	public int parse_only() {
		return this.io.getIntField(this, 60);
	}
	/**
	 * - decoding only: If true, only parsing is done<br>
	 * (function avcodec_parse_frame()). The frame<br>
	 * data is returned. Only MPEG codecs support this now.
	 */
	@Field(60) 
	public AVCodecContext parse_only(int parse_only) {
		this.io.setIntField(this, 60, parse_only);
		return this;
	}
	public final int parse_only_$eq(int parse_only) {
		parse_only(parse_only);
		return parse_only;
	}
	/**
	 * 0-> h263 quant 1-> mpeg quant<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(61) 
	public int mpeg_quant() {
		return this.io.getIntField(this, 61);
	}
	/**
	 * 0-> h263 quant 1-> mpeg quant<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(61) 
	public AVCodecContext mpeg_quant(int mpeg_quant) {
		this.io.setIntField(this, 61, mpeg_quant);
		return this;
	}
	public final int mpeg_quant_$eq(int mpeg_quant) {
		mpeg_quant(mpeg_quant);
		return mpeg_quant;
	}
	/**
	 * pass1 encoding statistics output buffer<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: unused<br>
	 * C type : char*
	 */
	@Field(62) 
	public Pointer<Byte > stats_out() {
		return this.io.getPointerField(this, 62);
	}
	/**
	 * pass1 encoding statistics output buffer<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: unused<br>
	 * C type : char*
	 */
	@Field(62) 
	public AVCodecContext stats_out(Pointer<Byte > stats_out) {
		this.io.setPointerField(this, 62, stats_out);
		return this;
	}
	/// C type : char*
	public final Pointer<Byte > stats_out_$eq(Pointer<Byte > stats_out) {
		stats_out(stats_out);
		return stats_out;
	}
	/**
	 * pass2 encoding statistics input buffer<br>
	 * Concatenated stuff from stats_out of pass1 should be placed here.<br>
	 * - encoding: Allocated/set/freed by user.<br>
	 * - decoding: unused<br>
	 * C type : char*
	 */
	@Field(63) 
	public Pointer<Byte > stats_in() {
		return this.io.getPointerField(this, 63);
	}
	/**
	 * pass2 encoding statistics input buffer<br>
	 * Concatenated stuff from stats_out of pass1 should be placed here.<br>
	 * - encoding: Allocated/set/freed by user.<br>
	 * - decoding: unused<br>
	 * C type : char*
	 */
	@Field(63) 
	public AVCodecContext stats_in(Pointer<Byte > stats_in) {
		this.io.setPointerField(this, 63, stats_in);
		return this;
	}
	/// C type : char*
	public final Pointer<Byte > stats_in_$eq(Pointer<Byte > stats_in) {
		stats_in(stats_in);
		return stats_in;
	}
	/**
	 * ratecontrol qmin qmax limiting method<br>
	 * 0-> clipping, 1-> use a nice continous function to limit qscale wthin qmin/qmax.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(64) 
	public float rc_qsquish() {
		return this.io.getFloatField(this, 64);
	}
	/**
	 * ratecontrol qmin qmax limiting method<br>
	 * 0-> clipping, 1-> use a nice continous function to limit qscale wthin qmin/qmax.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(64) 
	public AVCodecContext rc_qsquish(float rc_qsquish) {
		this.io.setFloatField(this, 64, rc_qsquish);
		return this;
	}
	public final float rc_qsquish_$eq(float rc_qsquish) {
		rc_qsquish(rc_qsquish);
		return rc_qsquish;
	}
	@Field(65) 
	public float rc_qmod_amp() {
		return this.io.getFloatField(this, 65);
	}
	@Field(65) 
	public AVCodecContext rc_qmod_amp(float rc_qmod_amp) {
		this.io.setFloatField(this, 65, rc_qmod_amp);
		return this;
	}
	public final float rc_qmod_amp_$eq(float rc_qmod_amp) {
		rc_qmod_amp(rc_qmod_amp);
		return rc_qmod_amp;
	}
	@Field(66) 
	public int rc_qmod_freq() {
		return this.io.getIntField(this, 66);
	}
	@Field(66) 
	public AVCodecContext rc_qmod_freq(int rc_qmod_freq) {
		this.io.setIntField(this, 66, rc_qmod_freq);
		return this;
	}
	public final int rc_qmod_freq_$eq(int rc_qmod_freq) {
		rc_qmod_freq(rc_qmod_freq);
		return rc_qmod_freq;
	}
	/**
	 * ratecontrol override, see RcOverride<br>
	 * - encoding: Allocated/set/freed by user.<br>
	 * - decoding: unused<br>
	 * C type : RcOverride*
	 */
	@Field(67) 
	public Pointer<RcOverride > rc_override() {
		return this.io.getPointerField(this, 67);
	}
	/**
	 * ratecontrol override, see RcOverride<br>
	 * - encoding: Allocated/set/freed by user.<br>
	 * - decoding: unused<br>
	 * C type : RcOverride*
	 */
	@Field(67) 
	public AVCodecContext rc_override(Pointer<RcOverride > rc_override) {
		this.io.setPointerField(this, 67, rc_override);
		return this;
	}
	/// C type : RcOverride*
	public final Pointer<RcOverride > rc_override_$eq(Pointer<RcOverride > rc_override) {
		rc_override(rc_override);
		return rc_override;
	}
	@Field(68) 
	public int rc_override_count() {
		return this.io.getIntField(this, 68);
	}
	@Field(68) 
	public AVCodecContext rc_override_count(int rc_override_count) {
		this.io.setIntField(this, 68, rc_override_count);
		return this;
	}
	public final int rc_override_count_$eq(int rc_override_count) {
		rc_override_count(rc_override_count);
		return rc_override_count;
	}
	/**
	 * rate control equation<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused<br>
	 * C type : const char*
	 */
	@Field(69) 
	public Pointer<Byte > rc_eq() {
		return this.io.getPointerField(this, 69);
	}
	/**
	 * rate control equation<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused<br>
	 * C type : const char*
	 */
	@Field(69) 
	public AVCodecContext rc_eq(Pointer<Byte > rc_eq) {
		this.io.setPointerField(this, 69, rc_eq);
		return this;
	}
	/// C type : const char*
	public final Pointer<Byte > rc_eq_$eq(Pointer<Byte > rc_eq) {
		rc_eq(rc_eq);
		return rc_eq;
	}
	/**
	 * maximum bitrate<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(70) 
	public int rc_max_rate() {
		return this.io.getIntField(this, 70);
	}
	/**
	 * maximum bitrate<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(70) 
	public AVCodecContext rc_max_rate(int rc_max_rate) {
		this.io.setIntField(this, 70, rc_max_rate);
		return this;
	}
	public final int rc_max_rate_$eq(int rc_max_rate) {
		rc_max_rate(rc_max_rate);
		return rc_max_rate;
	}
	/**
	 * minimum bitrate<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(71) 
	public int rc_min_rate() {
		return this.io.getIntField(this, 71);
	}
	/**
	 * minimum bitrate<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(71) 
	public AVCodecContext rc_min_rate(int rc_min_rate) {
		this.io.setIntField(this, 71, rc_min_rate);
		return this;
	}
	public final int rc_min_rate_$eq(int rc_min_rate) {
		rc_min_rate(rc_min_rate);
		return rc_min_rate;
	}
	/**
	 * decoder bitstream buffer size<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(72) 
	public int rc_buffer_size() {
		return this.io.getIntField(this, 72);
	}
	/**
	 * decoder bitstream buffer size<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(72) 
	public AVCodecContext rc_buffer_size(int rc_buffer_size) {
		this.io.setIntField(this, 72, rc_buffer_size);
		return this;
	}
	public final int rc_buffer_size_$eq(int rc_buffer_size) {
		rc_buffer_size(rc_buffer_size);
		return rc_buffer_size;
	}
	@Field(73) 
	public float rc_buffer_aggressivity() {
		return this.io.getFloatField(this, 73);
	}
	@Field(73) 
	public AVCodecContext rc_buffer_aggressivity(float rc_buffer_aggressivity) {
		this.io.setFloatField(this, 73, rc_buffer_aggressivity);
		return this;
	}
	public final float rc_buffer_aggressivity_$eq(float rc_buffer_aggressivity) {
		rc_buffer_aggressivity(rc_buffer_aggressivity);
		return rc_buffer_aggressivity;
	}
	/**
	 * qscale factor between P and I-frames<br>
	 * If > 0 then the last p frame quantizer will be used (q= lastp_q*factor+offset).<br>
	 * If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(74) 
	public float i_quant_factor() {
		return this.io.getFloatField(this, 74);
	}
	/**
	 * qscale factor between P and I-frames<br>
	 * If > 0 then the last p frame quantizer will be used (q= lastp_q*factor+offset).<br>
	 * If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(74) 
	public AVCodecContext i_quant_factor(float i_quant_factor) {
		this.io.setFloatField(this, 74, i_quant_factor);
		return this;
	}
	public final float i_quant_factor_$eq(float i_quant_factor) {
		i_quant_factor(i_quant_factor);
		return i_quant_factor;
	}
	/**
	 * qscale offset between P and I-frames<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(75) 
	public float i_quant_offset() {
		return this.io.getFloatField(this, 75);
	}
	/**
	 * qscale offset between P and I-frames<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(75) 
	public AVCodecContext i_quant_offset(float i_quant_offset) {
		this.io.setFloatField(this, 75, i_quant_offset);
		return this;
	}
	public final float i_quant_offset_$eq(float i_quant_offset) {
		i_quant_offset(i_quant_offset);
		return i_quant_offset;
	}
	/**
	 * initial complexity for pass1 ratecontrol<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(76) 
	public float rc_initial_cplx() {
		return this.io.getFloatField(this, 76);
	}
	/**
	 * initial complexity for pass1 ratecontrol<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(76) 
	public AVCodecContext rc_initial_cplx(float rc_initial_cplx) {
		this.io.setFloatField(this, 76, rc_initial_cplx);
		return this;
	}
	public final float rc_initial_cplx_$eq(float rc_initial_cplx) {
		rc_initial_cplx(rc_initial_cplx);
		return rc_initial_cplx;
	}
	/**
	 * DCT algorithm, see FF_DCT_* below<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(77) 
	public int dct_algo() {
		return this.io.getIntField(this, 77);
	}
	/**
	 * DCT algorithm, see FF_DCT_* below<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(77) 
	public AVCodecContext dct_algo(int dct_algo) {
		this.io.setIntField(this, 77, dct_algo);
		return this;
	}
	public final int dct_algo_$eq(int dct_algo) {
		dct_algo(dct_algo);
		return dct_algo;
	}
	/**
	 * luminance masking (0-> disabled)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(78) 
	public float lumi_masking() {
		return this.io.getFloatField(this, 78);
	}
	/**
	 * luminance masking (0-> disabled)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(78) 
	public AVCodecContext lumi_masking(float lumi_masking) {
		this.io.setFloatField(this, 78, lumi_masking);
		return this;
	}
	public final float lumi_masking_$eq(float lumi_masking) {
		lumi_masking(lumi_masking);
		return lumi_masking;
	}
	/**
	 * temporary complexity masking (0-> disabled)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(79) 
	public float temporal_cplx_masking() {
		return this.io.getFloatField(this, 79);
	}
	/**
	 * temporary complexity masking (0-> disabled)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(79) 
	public AVCodecContext temporal_cplx_masking(float temporal_cplx_masking) {
		this.io.setFloatField(this, 79, temporal_cplx_masking);
		return this;
	}
	public final float temporal_cplx_masking_$eq(float temporal_cplx_masking) {
		temporal_cplx_masking(temporal_cplx_masking);
		return temporal_cplx_masking;
	}
	/**
	 * spatial complexity masking (0-> disabled)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(80) 
	public float spatial_cplx_masking() {
		return this.io.getFloatField(this, 80);
	}
	/**
	 * spatial complexity masking (0-> disabled)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(80) 
	public AVCodecContext spatial_cplx_masking(float spatial_cplx_masking) {
		this.io.setFloatField(this, 80, spatial_cplx_masking);
		return this;
	}
	public final float spatial_cplx_masking_$eq(float spatial_cplx_masking) {
		spatial_cplx_masking(spatial_cplx_masking);
		return spatial_cplx_masking;
	}
	/**
	 * p block masking (0-> disabled)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(81) 
	public float p_masking() {
		return this.io.getFloatField(this, 81);
	}
	/**
	 * p block masking (0-> disabled)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(81) 
	public AVCodecContext p_masking(float p_masking) {
		this.io.setFloatField(this, 81, p_masking);
		return this;
	}
	public final float p_masking_$eq(float p_masking) {
		p_masking(p_masking);
		return p_masking;
	}
	/**
	 * darkness masking (0-> disabled)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(82) 
	public float dark_masking() {
		return this.io.getFloatField(this, 82);
	}
	/**
	 * darkness masking (0-> disabled)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(82) 
	public AVCodecContext dark_masking(float dark_masking) {
		this.io.setFloatField(this, 82, dark_masking);
		return this;
	}
	public final float dark_masking_$eq(float dark_masking) {
		dark_masking(dark_masking);
		return dark_masking;
	}
	/**
	 * IDCT algorithm, see FF_IDCT_* below.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.
	 */
	@Field(83) 
	public int idct_algo() {
		return this.io.getIntField(this, 83);
	}
	/**
	 * IDCT algorithm, see FF_IDCT_* below.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.
	 */
	@Field(83) 
	public AVCodecContext idct_algo(int idct_algo) {
		this.io.setIntField(this, 83, idct_algo);
		return this;
	}
	public final int idct_algo_$eq(int idct_algo) {
		idct_algo(idct_algo);
		return idct_algo;
	}
	/**
	 * slice count<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: Set by user (or 0).
	 */
	@Field(84) 
	public int slice_count() {
		return this.io.getIntField(this, 84);
	}
	/**
	 * slice count<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: Set by user (or 0).
	 */
	@Field(84) 
	public AVCodecContext slice_count(int slice_count) {
		this.io.setIntField(this, 84, slice_count);
		return this;
	}
	public final int slice_count_$eq(int slice_count) {
		slice_count(slice_count);
		return slice_count;
	}
	/**
	 * slice offsets in the frame in bytes<br>
	 * - encoding: Set/allocated by libavcodec.<br>
	 * - decoding: Set/allocated by user (or NULL).<br>
	 * C type : int*
	 */
	@Field(85) 
	public Pointer<Integer > slice_offset() {
		return this.io.getPointerField(this, 85);
	}
	/**
	 * slice offsets in the frame in bytes<br>
	 * - encoding: Set/allocated by libavcodec.<br>
	 * - decoding: Set/allocated by user (or NULL).<br>
	 * C type : int*
	 */
	@Field(85) 
	public AVCodecContext slice_offset(Pointer<Integer > slice_offset) {
		this.io.setPointerField(this, 85, slice_offset);
		return this;
	}
	/// C type : int*
	public final Pointer<Integer > slice_offset_$eq(Pointer<Integer > slice_offset) {
		slice_offset(slice_offset);
		return slice_offset;
	}
	/**
	 * error concealment flags<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	@Field(86) 
	public int error_concealment() {
		return this.io.getIntField(this, 86);
	}
	/**
	 * error concealment flags<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	@Field(86) 
	public AVCodecContext error_concealment(int error_concealment) {
		this.io.setIntField(this, 86, error_concealment);
		return this;
	}
	public final int error_concealment_$eq(int error_concealment) {
		error_concealment(error_concealment);
		return error_concealment;
	}
	/**
	 * dsp_mask could be add used to disable unwanted CPU features<br>
	 * CPU features (i.e. MMX, SSE. ...)<br>
	 * * With the FORCE flag you may instead enable given CPU features.<br>
	 * (Dangerous: Usable in case of misdetection, improper usage however will<br>
	 * result into program crash.)
	 */
	@Field(87) 
	public int dsp_mask() {
		return this.io.getIntField(this, 87);
	}
	/**
	 * dsp_mask could be add used to disable unwanted CPU features<br>
	 * CPU features (i.e. MMX, SSE. ...)<br>
	 * * With the FORCE flag you may instead enable given CPU features.<br>
	 * (Dangerous: Usable in case of misdetection, improper usage however will<br>
	 * result into program crash.)
	 */
	@Field(87) 
	public AVCodecContext dsp_mask(int dsp_mask) {
		this.io.setIntField(this, 87, dsp_mask);
		return this;
	}
	public final int dsp_mask_$eq(int dsp_mask) {
		dsp_mask(dsp_mask);
		return dsp_mask;
	}
	/**
	 * bits per sample/pixel from the demuxer (needed for huffyuv).<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: Set by user.
	 */
	@Field(88) 
	public int bits_per_coded_sample() {
		return this.io.getIntField(this, 88);
	}
	/**
	 * bits per sample/pixel from the demuxer (needed for huffyuv).<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: Set by user.
	 */
	@Field(88) 
	public AVCodecContext bits_per_coded_sample(int bits_per_coded_sample) {
		this.io.setIntField(this, 88, bits_per_coded_sample);
		return this;
	}
	public final int bits_per_coded_sample_$eq(int bits_per_coded_sample) {
		bits_per_coded_sample(bits_per_coded_sample);
		return bits_per_coded_sample;
	}
	/**
	 * prediction method (needed for huffyuv)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(89) 
	public int prediction_method() {
		return this.io.getIntField(this, 89);
	}
	/**
	 * prediction method (needed for huffyuv)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(89) 
	public AVCodecContext prediction_method(int prediction_method) {
		this.io.setIntField(this, 89, prediction_method);
		return this;
	}
	public final int prediction_method_$eq(int prediction_method) {
		prediction_method(prediction_method);
		return prediction_method;
	}
	/**
	 * sample aspect ratio (0 if unknown)<br>
	 * That is the width of a pixel divided by the height of the pixel.<br>
	 * Numerator and denominator must be relatively prime and smaller than 256 for some video standards.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by libavcodec.<br>
	 * C type : AVRational
	 */
	@Field(90) 
	public AVRational sample_aspect_ratio() {
		return this.io.getNativeObjectField(this, 90);
	}
	/**
	 * the picture in the bitstream<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: Set by libavcodec.<br>
	 * C type : AVFrame*
	 */
	@Field(91) 
	public Pointer<AVFrame > coded_frame() {
		return this.io.getPointerField(this, 91);
	}
	/**
	 * the picture in the bitstream<br>
	 * - encoding: Set by libavcodec.<br>
	 * - decoding: Set by libavcodec.<br>
	 * C type : AVFrame*
	 */
	@Field(91) 
	public AVCodecContext coded_frame(Pointer<AVFrame > coded_frame) {
		this.io.setPointerField(this, 91, coded_frame);
		return this;
	}
	/// C type : AVFrame*
	public final Pointer<AVFrame > coded_frame_$eq(Pointer<AVFrame > coded_frame) {
		coded_frame(coded_frame);
		return coded_frame;
	}
	/**
	 * debug<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.
	 */
	@Field(92) 
	public int debug() {
		return this.io.getIntField(this, 92);
	}
	/**
	 * debug<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.
	 */
	@Field(92) 
	public AVCodecContext debug(int debug) {
		this.io.setIntField(this, 92, debug);
		return this;
	}
	public final int debug_$eq(int debug) {
		debug(debug);
		return debug;
	}
	/**
	 * debug<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.
	 */
	@Field(93) 
	public int debug_mv() {
		return this.io.getIntField(this, 93);
	}
	/**
	 * debug<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.
	 */
	@Field(93) 
	public AVCodecContext debug_mv(int debug_mv) {
		this.io.setIntField(this, 93, debug_mv);
		return this;
	}
	public final int debug_mv_$eq(int debug_mv) {
		debug_mv(debug_mv);
		return debug_mv;
	}
	/**
	 * error<br>
	 * - encoding: Set by libavcodec if flags&CODEC_FLAG_PSNR.<br>
	 * - decoding: unused<br>
	 * C type : uint64_t[4]
	 */
	@Array({4}) 
	@Field(94) 
	public Pointer<Long > error() {
		return this.io.getPointerField(this, 94);
	}
	/**
	 * minimum MB quantizer<br>
	 * - encoding: unused<br>
	 * - decoding: unused
	 */
	@Field(95) 
	public int mb_qmin() {
		return this.io.getIntField(this, 95);
	}
	/**
	 * minimum MB quantizer<br>
	 * - encoding: unused<br>
	 * - decoding: unused
	 */
	@Field(95) 
	public AVCodecContext mb_qmin(int mb_qmin) {
		this.io.setIntField(this, 95, mb_qmin);
		return this;
	}
	public final int mb_qmin_$eq(int mb_qmin) {
		mb_qmin(mb_qmin);
		return mb_qmin;
	}
	/**
	 * maximum MB quantizer<br>
	 * - encoding: unused<br>
	 * - decoding: unused
	 */
	@Field(96) 
	public int mb_qmax() {
		return this.io.getIntField(this, 96);
	}
	/**
	 * maximum MB quantizer<br>
	 * - encoding: unused<br>
	 * - decoding: unused
	 */
	@Field(96) 
	public AVCodecContext mb_qmax(int mb_qmax) {
		this.io.setIntField(this, 96, mb_qmax);
		return this;
	}
	public final int mb_qmax_$eq(int mb_qmax) {
		mb_qmax(mb_qmax);
		return mb_qmax;
	}
	/**
	 * motion estimation comparison function<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(97) 
	public int me_cmp() {
		return this.io.getIntField(this, 97);
	}
	/**
	 * motion estimation comparison function<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(97) 
	public AVCodecContext me_cmp(int me_cmp) {
		this.io.setIntField(this, 97, me_cmp);
		return this;
	}
	public final int me_cmp_$eq(int me_cmp) {
		me_cmp(me_cmp);
		return me_cmp;
	}
	/**
	 * subpixel motion estimation comparison function<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(98) 
	public int me_sub_cmp() {
		return this.io.getIntField(this, 98);
	}
	/**
	 * subpixel motion estimation comparison function<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(98) 
	public AVCodecContext me_sub_cmp(int me_sub_cmp) {
		this.io.setIntField(this, 98, me_sub_cmp);
		return this;
	}
	public final int me_sub_cmp_$eq(int me_sub_cmp) {
		me_sub_cmp(me_sub_cmp);
		return me_sub_cmp;
	}
	/**
	 * macroblock comparison function (not supported yet)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(99) 
	public int mb_cmp() {
		return this.io.getIntField(this, 99);
	}
	/**
	 * macroblock comparison function (not supported yet)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(99) 
	public AVCodecContext mb_cmp(int mb_cmp) {
		this.io.setIntField(this, 99, mb_cmp);
		return this;
	}
	public final int mb_cmp_$eq(int mb_cmp) {
		mb_cmp(mb_cmp);
		return mb_cmp;
	}
	/**
	 * interlaced DCT comparison function<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(100) 
	public int ildct_cmp() {
		return this.io.getIntField(this, 100);
	}
	/**
	 * interlaced DCT comparison function<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(100) 
	public AVCodecContext ildct_cmp(int ildct_cmp) {
		this.io.setIntField(this, 100, ildct_cmp);
		return this;
	}
	public final int ildct_cmp_$eq(int ildct_cmp) {
		ildct_cmp(ildct_cmp);
		return ildct_cmp;
	}
	/**
	 * ME diamond size & shape<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(101) 
	public int dia_size() {
		return this.io.getIntField(this, 101);
	}
	/**
	 * ME diamond size & shape<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(101) 
	public AVCodecContext dia_size(int dia_size) {
		this.io.setIntField(this, 101, dia_size);
		return this;
	}
	public final int dia_size_$eq(int dia_size) {
		dia_size(dia_size);
		return dia_size;
	}
	/**
	 * amount of previous MV predictors (2a+1 x 2a+1 square)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(102) 
	public int last_predictor_count() {
		return this.io.getIntField(this, 102);
	}
	/**
	 * amount of previous MV predictors (2a+1 x 2a+1 square)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(102) 
	public AVCodecContext last_predictor_count(int last_predictor_count) {
		this.io.setIntField(this, 102, last_predictor_count);
		return this;
	}
	public final int last_predictor_count_$eq(int last_predictor_count) {
		last_predictor_count(last_predictor_count);
		return last_predictor_count;
	}
	/**
	 * prepass for motion estimation<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(103) 
	public int pre_me() {
		return this.io.getIntField(this, 103);
	}
	/**
	 * prepass for motion estimation<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(103) 
	public AVCodecContext pre_me(int pre_me) {
		this.io.setIntField(this, 103, pre_me);
		return this;
	}
	public final int pre_me_$eq(int pre_me) {
		pre_me(pre_me);
		return pre_me;
	}
	/**
	 * motion estimation prepass comparison function<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(104) 
	public int me_pre_cmp() {
		return this.io.getIntField(this, 104);
	}
	/**
	 * motion estimation prepass comparison function<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(104) 
	public AVCodecContext me_pre_cmp(int me_pre_cmp) {
		this.io.setIntField(this, 104, me_pre_cmp);
		return this;
	}
	public final int me_pre_cmp_$eq(int me_pre_cmp) {
		me_pre_cmp(me_pre_cmp);
		return me_pre_cmp;
	}
	/**
	 * ME prepass diamond size & shape<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(105) 
	public int pre_dia_size() {
		return this.io.getIntField(this, 105);
	}
	/**
	 * ME prepass diamond size & shape<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(105) 
	public AVCodecContext pre_dia_size(int pre_dia_size) {
		this.io.setIntField(this, 105, pre_dia_size);
		return this;
	}
	public final int pre_dia_size_$eq(int pre_dia_size) {
		pre_dia_size(pre_dia_size);
		return pre_dia_size;
	}
	/**
	 * subpel ME quality<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(106) 
	public int me_subpel_quality() {
		return this.io.getIntField(this, 106);
	}
	/**
	 * subpel ME quality<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(106) 
	public AVCodecContext me_subpel_quality(int me_subpel_quality) {
		this.io.setIntField(this, 106, me_subpel_quality);
		return this;
	}
	public final int me_subpel_quality_$eq(int me_subpel_quality) {
		me_subpel_quality(me_subpel_quality);
		return me_subpel_quality;
	}
	/**
	 * callback to negotiate the pixelFormat<br>
	 * @param fmt is the list of formats which are supported by the codec,<br>
	 * it is terminated by -1 as 0 is a valid format, the formats are ordered by quality.<br>
	 * The first is always the native one.<br>
	 * @return the chosen format<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user, if not set the native format will be chosen.<br>
	 * C type : get_format_callback
	 */
	@Field(107) 
	public Pointer<AVCodecContext.get_format_callback > get_format() {
		return this.io.getPointerField(this, 107);
	}
	/**
	 * callback to negotiate the pixelFormat<br>
	 * @param fmt is the list of formats which are supported by the codec,<br>
	 * it is terminated by -1 as 0 is a valid format, the formats are ordered by quality.<br>
	 * The first is always the native one.<br>
	 * @return the chosen format<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user, if not set the native format will be chosen.<br>
	 * C type : get_format_callback
	 */
	@Field(107) 
	public AVCodecContext get_format(Pointer<AVCodecContext.get_format_callback > get_format) {
		this.io.setPointerField(this, 107, get_format);
		return this;
	}
	/// C type : get_format_callback
	public final Pointer<AVCodecContext.get_format_callback > get_format_$eq(Pointer<AVCodecContext.get_format_callback > get_format) {
		get_format(get_format);
		return get_format;
	}
	/**
	 * DTG active format information (additional aspect ratio<br>
	 * information only used in DVB MPEG-2 transport streams)<br>
	 * 0 if not set.<br>
	 * * - encoding: unused<br>
	 * - decoding: Set by decoder.
	 */
	@Field(108) 
	public int dtg_active_format() {
		return this.io.getIntField(this, 108);
	}
	/**
	 * DTG active format information (additional aspect ratio<br>
	 * information only used in DVB MPEG-2 transport streams)<br>
	 * 0 if not set.<br>
	 * * - encoding: unused<br>
	 * - decoding: Set by decoder.
	 */
	@Field(108) 
	public AVCodecContext dtg_active_format(int dtg_active_format) {
		this.io.setIntField(this, 108, dtg_active_format);
		return this;
	}
	public final int dtg_active_format_$eq(int dtg_active_format) {
		dtg_active_format(dtg_active_format);
		return dtg_active_format;
	}
	/**
	 * maximum motion estimation search range in subpel units<br>
	 * If 0 then no limit.<br>
	 * * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(109) 
	public int me_range() {
		return this.io.getIntField(this, 109);
	}
	/**
	 * maximum motion estimation search range in subpel units<br>
	 * If 0 then no limit.<br>
	 * * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(109) 
	public AVCodecContext me_range(int me_range) {
		this.io.setIntField(this, 109, me_range);
		return this;
	}
	public final int me_range_$eq(int me_range) {
		me_range(me_range);
		return me_range;
	}
	/**
	 * intra quantizer bias<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(110) 
	public int intra_quant_bias() {
		return this.io.getIntField(this, 110);
	}
	/**
	 * intra quantizer bias<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(110) 
	public AVCodecContext intra_quant_bias(int intra_quant_bias) {
		this.io.setIntField(this, 110, intra_quant_bias);
		return this;
	}
	public final int intra_quant_bias_$eq(int intra_quant_bias) {
		intra_quant_bias(intra_quant_bias);
		return intra_quant_bias;
	}
	/**
	 * inter quantizer bias<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(111) 
	public int inter_quant_bias() {
		return this.io.getIntField(this, 111);
	}
	/**
	 * inter quantizer bias<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(111) 
	public AVCodecContext inter_quant_bias(int inter_quant_bias) {
		this.io.setIntField(this, 111, inter_quant_bias);
		return this;
	}
	public final int inter_quant_bias_$eq(int inter_quant_bias) {
		inter_quant_bias(inter_quant_bias);
		return inter_quant_bias;
	}
	/**
	 * color table ID<br>
	 * - encoding: unused<br>
	 * - decoding: Which clrtable should be used for 8bit RGB images.<br>
	 *             Tables have to be stored somewhere. FIXME
	 */
	@Field(112) 
	public int color_table_id() {
		return this.io.getIntField(this, 112);
	}
	/**
	 * color table ID<br>
	 * - encoding: unused<br>
	 * - decoding: Which clrtable should be used for 8bit RGB images.<br>
	 *             Tables have to be stored somewhere. FIXME
	 */
	@Field(112) 
	public AVCodecContext color_table_id(int color_table_id) {
		this.io.setIntField(this, 112, color_table_id);
		return this;
	}
	public final int color_table_id_$eq(int color_table_id) {
		color_table_id(color_table_id);
		return color_table_id;
	}
	/**
	 * internal_buffer count<br>
	 * Don't touch, used by libavcodec default_get_buffer().
	 */
	@Field(113) 
	public int internal_buffer_count() {
		return this.io.getIntField(this, 113);
	}
	/**
	 * internal_buffer count<br>
	 * Don't touch, used by libavcodec default_get_buffer().
	 */
	@Field(113) 
	public AVCodecContext internal_buffer_count(int internal_buffer_count) {
		this.io.setIntField(this, 113, internal_buffer_count);
		return this;
	}
	public final int internal_buffer_count_$eq(int internal_buffer_count) {
		internal_buffer_count(internal_buffer_count);
		return internal_buffer_count;
	}
	/**
	 * internal_buffers<br>
	 * Don't touch, used by libavcodec default_get_buffer().<br>
	 * C type : void*
	 */
	@Field(114) 
	public Pointer<? > internal_buffer() {
		return this.io.getPointerField(this, 114);
	}
	/**
	 * internal_buffers<br>
	 * Don't touch, used by libavcodec default_get_buffer().<br>
	 * C type : void*
	 */
	@Field(114) 
	public AVCodecContext internal_buffer(Pointer<? > internal_buffer) {
		this.io.setPointerField(this, 114, internal_buffer);
		return this;
	}
	/// C type : void*
	public final Pointer<? > internal_buffer_$eq(Pointer<? > internal_buffer) {
		internal_buffer(internal_buffer);
		return internal_buffer;
	}
	/**
	 * Global quality for codecs which cannot change it per frame.<br>
	 * This should be proportional to MPEG-1/2/4 qscale.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(115) 
	public int global_quality() {
		return this.io.getIntField(this, 115);
	}
	/**
	 * Global quality for codecs which cannot change it per frame.<br>
	 * This should be proportional to MPEG-1/2/4 qscale.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(115) 
	public AVCodecContext global_quality(int global_quality) {
		this.io.setIntField(this, 115, global_quality);
		return this;
	}
	public final int global_quality_$eq(int global_quality) {
		global_quality(global_quality);
		return global_quality;
	}
	/**
	 * coder type<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(116) 
	public int coder_type() {
		return this.io.getIntField(this, 116);
	}
	/**
	 * coder type<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(116) 
	public AVCodecContext coder_type(int coder_type) {
		this.io.setIntField(this, 116, coder_type);
		return this;
	}
	public final int coder_type_$eq(int coder_type) {
		coder_type(coder_type);
		return coder_type;
	}
	/**
	 * context model<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(117) 
	public int context_model() {
		return this.io.getIntField(this, 117);
	}
	/**
	 * context model<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(117) 
	public AVCodecContext context_model(int context_model) {
		this.io.setIntField(this, 117, context_model);
		return this;
	}
	public final int context_model_$eq(int context_model) {
		context_model(context_model);
		return context_model;
	}
	/**
	 * slice flags<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	@Field(118) 
	public int slice_flags() {
		return this.io.getIntField(this, 118);
	}
	/**
	 * slice flags<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	@Field(118) 
	public AVCodecContext slice_flags(int slice_flags) {
		this.io.setIntField(this, 118, slice_flags);
		return this;
	}
	public final int slice_flags_$eq(int slice_flags) {
		slice_flags(slice_flags);
		return slice_flags;
	}
	/**
	 * XVideo Motion Acceleration<br>
	 * - encoding: forbidden<br>
	 * - decoding: set by decoder
	 */
	@Field(119) 
	public int xvmc_acceleration() {
		return this.io.getIntField(this, 119);
	}
	/**
	 * XVideo Motion Acceleration<br>
	 * - encoding: forbidden<br>
	 * - decoding: set by decoder
	 */
	@Field(119) 
	public AVCodecContext xvmc_acceleration(int xvmc_acceleration) {
		this.io.setIntField(this, 119, xvmc_acceleration);
		return this;
	}
	public final int xvmc_acceleration_$eq(int xvmc_acceleration) {
		xvmc_acceleration(xvmc_acceleration);
		return xvmc_acceleration;
	}
	/**
	 * macroblock decision mode<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(120) 
	public int mb_decision() {
		return this.io.getIntField(this, 120);
	}
	/**
	 * macroblock decision mode<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(120) 
	public AVCodecContext mb_decision(int mb_decision) {
		this.io.setIntField(this, 120, mb_decision);
		return this;
	}
	public final int mb_decision_$eq(int mb_decision) {
		mb_decision(mb_decision);
		return mb_decision;
	}
	/**
	 * custom intra quantization matrix<br>
	 * - encoding: Set by user, can be NULL.<br>
	 * - decoding: Set by libavcodec.<br>
	 * C type : uint16_t*
	 */
	@Field(121) 
	public Pointer<Short > intra_matrix() {
		return this.io.getPointerField(this, 121);
	}
	/**
	 * custom intra quantization matrix<br>
	 * - encoding: Set by user, can be NULL.<br>
	 * - decoding: Set by libavcodec.<br>
	 * C type : uint16_t*
	 */
	@Field(121) 
	public AVCodecContext intra_matrix(Pointer<Short > intra_matrix) {
		this.io.setPointerField(this, 121, intra_matrix);
		return this;
	}
	/// C type : uint16_t*
	public final Pointer<Short > intra_matrix_$eq(Pointer<Short > intra_matrix) {
		intra_matrix(intra_matrix);
		return intra_matrix;
	}
	/**
	 * custom inter quantization matrix<br>
	 * - encoding: Set by user, can be NULL.<br>
	 * - decoding: Set by libavcodec.<br>
	 * C type : uint16_t*
	 */
	@Field(122) 
	public Pointer<Short > inter_matrix() {
		return this.io.getPointerField(this, 122);
	}
	/**
	 * custom inter quantization matrix<br>
	 * - encoding: Set by user, can be NULL.<br>
	 * - decoding: Set by libavcodec.<br>
	 * C type : uint16_t*
	 */
	@Field(122) 
	public AVCodecContext inter_matrix(Pointer<Short > inter_matrix) {
		this.io.setPointerField(this, 122, inter_matrix);
		return this;
	}
	/// C type : uint16_t*
	public final Pointer<Short > inter_matrix_$eq(Pointer<Short > inter_matrix) {
		inter_matrix(inter_matrix);
		return inter_matrix;
	}
	/**
	 * fourcc from the AVI stream header (LSB first, so "ABCD" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').<br>
	 * This is used to work around some encoder bugs.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user, will be converted to uppercase by libavcodec during init.
	 */
	@Field(123) 
	public int stream_codec_tag() {
		return this.io.getIntField(this, 123);
	}
	/**
	 * fourcc from the AVI stream header (LSB first, so "ABCD" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').<br>
	 * This is used to work around some encoder bugs.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user, will be converted to uppercase by libavcodec during init.
	 */
	@Field(123) 
	public AVCodecContext stream_codec_tag(int stream_codec_tag) {
		this.io.setIntField(this, 123, stream_codec_tag);
		return this;
	}
	public final int stream_codec_tag_$eq(int stream_codec_tag) {
		stream_codec_tag(stream_codec_tag);
		return stream_codec_tag;
	}
	/**
	 * scene change detection threshold<br>
	 * 0 is default, larger means fewer detected scene changes.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(124) 
	public int scenechange_threshold() {
		return this.io.getIntField(this, 124);
	}
	/**
	 * scene change detection threshold<br>
	 * 0 is default, larger means fewer detected scene changes.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(124) 
	public AVCodecContext scenechange_threshold(int scenechange_threshold) {
		this.io.setIntField(this, 124, scenechange_threshold);
		return this;
	}
	public final int scenechange_threshold_$eq(int scenechange_threshold) {
		scenechange_threshold(scenechange_threshold);
		return scenechange_threshold;
	}
	/**
	 * minimum Lagrange multipler<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(125) 
	public int lmin() {
		return this.io.getIntField(this, 125);
	}
	/**
	 * minimum Lagrange multipler<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(125) 
	public AVCodecContext lmin(int lmin) {
		this.io.setIntField(this, 125, lmin);
		return this;
	}
	public final int lmin_$eq(int lmin) {
		lmin(lmin);
		return lmin;
	}
	/**
	 * maximum Lagrange multipler<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(126) 
	public int lmax() {
		return this.io.getIntField(this, 126);
	}
	/**
	 * maximum Lagrange multipler<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(126) 
	public AVCodecContext lmax(int lmax) {
		this.io.setIntField(this, 126, lmax);
		return this;
	}
	public final int lmax_$eq(int lmax) {
		lmax(lmax);
		return lmax;
	}
	/**
	 * palette control structure<br>
	 * - encoding: ??? (no palette-enabled encoder yet)<br>
	 * - decoding: Set by user.<br>
	 * C type : AVPaletteControl*
	 */
	@Field(127) 
	public Pointer<AVPaletteControl > palctrl() {
		return this.io.getPointerField(this, 127);
	}
	/**
	 * palette control structure<br>
	 * - encoding: ??? (no palette-enabled encoder yet)<br>
	 * - decoding: Set by user.<br>
	 * C type : AVPaletteControl*
	 */
	@Field(127) 
	public AVCodecContext palctrl(Pointer<AVPaletteControl > palctrl) {
		this.io.setPointerField(this, 127, palctrl);
		return this;
	}
	/// C type : AVPaletteControl*
	public final Pointer<AVPaletteControl > palctrl_$eq(Pointer<AVPaletteControl > palctrl) {
		palctrl(palctrl);
		return palctrl;
	}
	/**
	 * noise reduction strength<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(128) 
	public int noise_reduction() {
		return this.io.getIntField(this, 128);
	}
	/**
	 * noise reduction strength<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(128) 
	public AVCodecContext noise_reduction(int noise_reduction) {
		this.io.setIntField(this, 128, noise_reduction);
		return this;
	}
	public final int noise_reduction_$eq(int noise_reduction) {
		noise_reduction(noise_reduction);
		return noise_reduction;
	}
	/**
	 * Called at the beginning of a frame to get cr buffer for it.<br>
	 * Buffer type (size, hints) must be the same. libavcodec won't check it.<br>
	 * libavcodec will pass previous buffer in pic, function should return<br>
	 * same buffer or new buffer with old frame "painted" into it.<br>
	 * If pic.data[0] == NULL must behave like get_buffer().<br>
	 * if CODEC_CAP_DR1 is not set then reget_buffer() must call<br>
	 * avcodec_default_reget_buffer() instead of providing buffers allocated by<br>
	 * some other means.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by libavcodec, user can override.<br>
	 * C type : reget_buffer_callback
	 */
	@Field(129) 
	public Pointer<AVCodecContext.reget_buffer_callback > reget_buffer() {
		return this.io.getPointerField(this, 129);
	}
	/**
	 * Called at the beginning of a frame to get cr buffer for it.<br>
	 * Buffer type (size, hints) must be the same. libavcodec won't check it.<br>
	 * libavcodec will pass previous buffer in pic, function should return<br>
	 * same buffer or new buffer with old frame "painted" into it.<br>
	 * If pic.data[0] == NULL must behave like get_buffer().<br>
	 * if CODEC_CAP_DR1 is not set then reget_buffer() must call<br>
	 * avcodec_default_reget_buffer() instead of providing buffers allocated by<br>
	 * some other means.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by libavcodec, user can override.<br>
	 * C type : reget_buffer_callback
	 */
	@Field(129) 
	public AVCodecContext reget_buffer(Pointer<AVCodecContext.reget_buffer_callback > reget_buffer) {
		this.io.setPointerField(this, 129, reget_buffer);
		return this;
	}
	/// C type : reget_buffer_callback
	public final Pointer<AVCodecContext.reget_buffer_callback > reget_buffer_$eq(Pointer<AVCodecContext.reget_buffer_callback > reget_buffer) {
		reget_buffer(reget_buffer);
		return reget_buffer;
	}
	/**
	 * Number of bits which should be loaded into the rc buffer before decoding starts.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(130) 
	public int rc_initial_buffer_occupancy() {
		return this.io.getIntField(this, 130);
	}
	/**
	 * Number of bits which should be loaded into the rc buffer before decoding starts.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(130) 
	public AVCodecContext rc_initial_buffer_occupancy(int rc_initial_buffer_occupancy) {
		this.io.setIntField(this, 130, rc_initial_buffer_occupancy);
		return this;
	}
	public final int rc_initial_buffer_occupancy_$eq(int rc_initial_buffer_occupancy) {
		rc_initial_buffer_occupancy(rc_initial_buffer_occupancy);
		return rc_initial_buffer_occupancy;
	}
	/**
	 * * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(131) 
	public int inter_threshold() {
		return this.io.getIntField(this, 131);
	}
	/**
	 * * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(131) 
	public AVCodecContext inter_threshold(int inter_threshold) {
		this.io.setIntField(this, 131, inter_threshold);
		return this;
	}
	public final int inter_threshold_$eq(int inter_threshold) {
		inter_threshold(inter_threshold);
		return inter_threshold;
	}
	/**
	 * CODEC_FLAG2_*<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.
	 */
	@Field(132) 
	public int flags2() {
		return this.io.getIntField(this, 132);
	}
	/**
	 * CODEC_FLAG2_*<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.
	 */
	@Field(132) 
	public AVCodecContext flags2(int flags2) {
		this.io.setIntField(this, 132, flags2);
		return this;
	}
	public final int flags2_$eq(int flags2) {
		flags2(flags2);
		return flags2;
	}
	/**
	 * Simulates errors in the bitstream to test error concealment.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(133) 
	public int error_rate() {
		return this.io.getIntField(this, 133);
	}
	/**
	 * Simulates errors in the bitstream to test error concealment.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(133) 
	public AVCodecContext error_rate(int error_rate) {
		this.io.setIntField(this, 133, error_rate);
		return this;
	}
	public final int error_rate_$eq(int error_rate) {
		error_rate(error_rate);
		return error_rate;
	}
	/**
	 * MP3 antialias algorithm, see FF_AA_* below.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	@Field(134) 
	public int antialias_algo() {
		return this.io.getIntField(this, 134);
	}
	/**
	 * MP3 antialias algorithm, see FF_AA_* below.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	@Field(134) 
	public AVCodecContext antialias_algo(int antialias_algo) {
		this.io.setIntField(this, 134, antialias_algo);
		return this;
	}
	public final int antialias_algo_$eq(int antialias_algo) {
		antialias_algo(antialias_algo);
		return antialias_algo;
	}
	/**
	 * quantizer noise shaping<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(135) 
	public int quantizer_noise_shaping() {
		return this.io.getIntField(this, 135);
	}
	/**
	 * quantizer noise shaping<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(135) 
	public AVCodecContext quantizer_noise_shaping(int quantizer_noise_shaping) {
		this.io.setIntField(this, 135, quantizer_noise_shaping);
		return this;
	}
	public final int quantizer_noise_shaping_$eq(int quantizer_noise_shaping) {
		quantizer_noise_shaping(quantizer_noise_shaping);
		return quantizer_noise_shaping;
	}
	/**
	 * thread count<br>
	 * is used to decide how many independent tasks should be passed to execute()<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.
	 */
	@Field(136) 
	public int thread_count() {
		return this.io.getIntField(this, 136);
	}
	/**
	 * thread count<br>
	 * is used to decide how many independent tasks should be passed to execute()<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by user.
	 */
	@Field(136) 
	public AVCodecContext thread_count(int thread_count) {
		this.io.setIntField(this, 136, thread_count);
		return this;
	}
	public final int thread_count_$eq(int thread_count) {
		thread_count(thread_count);
		return thread_count;
	}
	/**
	 * The codec may call this to execute several independent things.<br>
	 * It will return only after finishing all tasks.<br>
	 * The user may replace this with some multithreaded implementation,<br>
	 * the default implementation will execute the parts serially.<br>
	 * @param count the number of things to execute<br>
	 * - encoding: Set by libavcodec, user can override.<br>
	 * - decoding: Set by libavcodec, user can override.<br>
	 * C type : execute_callback
	 */
	@Field(137) 
	public Pointer<AVCodecContext.execute_callback > execute() {
		return this.io.getPointerField(this, 137);
	}
	/**
	 * The codec may call this to execute several independent things.<br>
	 * It will return only after finishing all tasks.<br>
	 * The user may replace this with some multithreaded implementation,<br>
	 * the default implementation will execute the parts serially.<br>
	 * @param count the number of things to execute<br>
	 * - encoding: Set by libavcodec, user can override.<br>
	 * - decoding: Set by libavcodec, user can override.<br>
	 * C type : execute_callback
	 */
	@Field(137) 
	public AVCodecContext execute(Pointer<AVCodecContext.execute_callback > execute) {
		this.io.setPointerField(this, 137, execute);
		return this;
	}
	/// C type : execute_callback
	public final Pointer<AVCodecContext.execute_callback > execute_$eq(Pointer<AVCodecContext.execute_callback > execute) {
		execute(execute);
		return execute;
	}
	/**
	 * thread opaque<br>
	 * Can be used by execute() to store some per AVCodecContext stuff.<br>
	 * - encoding: set by execute()<br>
	 * - decoding: set by execute()<br>
	 * C type : void*
	 */
	@Field(138) 
	public Pointer<? > thread_opaque() {
		return this.io.getPointerField(this, 138);
	}
	/**
	 * thread opaque<br>
	 * Can be used by execute() to store some per AVCodecContext stuff.<br>
	 * - encoding: set by execute()<br>
	 * - decoding: set by execute()<br>
	 * C type : void*
	 */
	@Field(138) 
	public AVCodecContext thread_opaque(Pointer<? > thread_opaque) {
		this.io.setPointerField(this, 138, thread_opaque);
		return this;
	}
	/// C type : void*
	public final Pointer<? > thread_opaque_$eq(Pointer<? > thread_opaque) {
		thread_opaque(thread_opaque);
		return thread_opaque;
	}
	/**
	 * Motion estimation threshold below which no motion estimation is<br>
	 * performed, but instead the user specified motion vectors are used.<br>
	 * * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(139) 
	public int me_threshold() {
		return this.io.getIntField(this, 139);
	}
	/**
	 * Motion estimation threshold below which no motion estimation is<br>
	 * performed, but instead the user specified motion vectors are used.<br>
	 * * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(139) 
	public AVCodecContext me_threshold(int me_threshold) {
		this.io.setIntField(this, 139, me_threshold);
		return this;
	}
	public final int me_threshold_$eq(int me_threshold) {
		me_threshold(me_threshold);
		return me_threshold;
	}
	/**
	 * Macroblock threshold below which the user specified macroblock types will be used.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(140) 
	public int mb_threshold() {
		return this.io.getIntField(this, 140);
	}
	/**
	 * Macroblock threshold below which the user specified macroblock types will be used.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(140) 
	public AVCodecContext mb_threshold(int mb_threshold) {
		this.io.setIntField(this, 140, mb_threshold);
		return this;
	}
	public final int mb_threshold_$eq(int mb_threshold) {
		mb_threshold(mb_threshold);
		return mb_threshold;
	}
	/**
	 * precision of the intra DC coefficient - 8<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(141) 
	public int intra_dc_precision() {
		return this.io.getIntField(this, 141);
	}
	/**
	 * precision of the intra DC coefficient - 8<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(141) 
	public AVCodecContext intra_dc_precision(int intra_dc_precision) {
		this.io.setIntField(this, 141, intra_dc_precision);
		return this;
	}
	public final int intra_dc_precision_$eq(int intra_dc_precision) {
		intra_dc_precision(intra_dc_precision);
		return intra_dc_precision;
	}
	/**
	 * noise vs. sse weight for the nsse comparsion function<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(142) 
	public int nsse_weight() {
		return this.io.getIntField(this, 142);
	}
	/**
	 * noise vs. sse weight for the nsse comparsion function<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(142) 
	public AVCodecContext nsse_weight(int nsse_weight) {
		this.io.setIntField(this, 142, nsse_weight);
		return this;
	}
	public final int nsse_weight_$eq(int nsse_weight) {
		nsse_weight(nsse_weight);
		return nsse_weight;
	}
	/**
	 * Number of macroblock rows at the top which are skipped.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	@Field(143) 
	public int skip_top() {
		return this.io.getIntField(this, 143);
	}
	/**
	 * Number of macroblock rows at the top which are skipped.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	@Field(143) 
	public AVCodecContext skip_top(int skip_top) {
		this.io.setIntField(this, 143, skip_top);
		return this;
	}
	public final int skip_top_$eq(int skip_top) {
		skip_top(skip_top);
		return skip_top;
	}
	/**
	 * Number of macroblock rows at the bottom which are skipped.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	@Field(144) 
	public int skip_bottom() {
		return this.io.getIntField(this, 144);
	}
	/**
	 * Number of macroblock rows at the bottom which are skipped.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	@Field(144) 
	public AVCodecContext skip_bottom(int skip_bottom) {
		this.io.setIntField(this, 144, skip_bottom);
		return this;
	}
	public final int skip_bottom_$eq(int skip_bottom) {
		skip_bottom(skip_bottom);
		return skip_bottom;
	}
	/**
	 * profile<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by libavcodec.
	 */
	@Field(145) 
	public int profile() {
		return this.io.getIntField(this, 145);
	}
	/**
	 * profile<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by libavcodec.
	 */
	@Field(145) 
	public AVCodecContext profile(int profile) {
		this.io.setIntField(this, 145, profile);
		return this;
	}
	public final int profile_$eq(int profile) {
		profile(profile);
		return profile;
	}
	/**
	 * level<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by libavcodec.
	 */
	@Field(146) 
	public int level() {
		return this.io.getIntField(this, 146);
	}
	/**
	 * level<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by libavcodec.
	 */
	@Field(146) 
	public AVCodecContext level(int level) {
		this.io.setIntField(this, 146, level);
		return this;
	}
	public final int level_$eq(int level) {
		level(level);
		return level;
	}
	/**
	 * low resolution decoding, 1-> 1/2 size, 2->1/4 size<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	@Field(147) 
	public int lowres() {
		return this.io.getIntField(this, 147);
	}
	/**
	 * low resolution decoding, 1-> 1/2 size, 2->1/4 size<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	@Field(147) 
	public AVCodecContext lowres(int lowres) {
		this.io.setIntField(this, 147, lowres);
		return this;
	}
	public final int lowres_$eq(int lowres) {
		lowres(lowres);
		return lowres;
	}
	/**
	 * Bitstream width / height, may be different from width/height if lowres<br>
	 * or other things are used.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user before init if known. Codec should override / dynamically change if needed.
	 */
	@Field(148) 
	public int coded_width() {
		return this.io.getIntField(this, 148);
	}
	/**
	 * Bitstream width / height, may be different from width/height if lowres<br>
	 * or other things are used.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user before init if known. Codec should override / dynamically change if needed.
	 */
	@Field(148) 
	public AVCodecContext coded_width(int coded_width) {
		this.io.setIntField(this, 148, coded_width);
		return this;
	}
	public final int coded_width_$eq(int coded_width) {
		coded_width(coded_width);
		return coded_width;
	}
	/**
	 * Bitstream width / height, may be different from width/height if lowres<br>
	 * or other things are used.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user before init if known. Codec should override / dynamically change if needed.
	 */
	@Field(149) 
	public int coded_height() {
		return this.io.getIntField(this, 149);
	}
	/**
	 * Bitstream width / height, may be different from width/height if lowres<br>
	 * or other things are used.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user before init if known. Codec should override / dynamically change if needed.
	 */
	@Field(149) 
	public AVCodecContext coded_height(int coded_height) {
		this.io.setIntField(this, 149, coded_height);
		return this;
	}
	public final int coded_height_$eq(int coded_height) {
		coded_height(coded_height);
		return coded_height;
	}
	/**
	 * frame skip threshold<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(150) 
	public int frame_skip_threshold() {
		return this.io.getIntField(this, 150);
	}
	/**
	 * frame skip threshold<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(150) 
	public AVCodecContext frame_skip_threshold(int frame_skip_threshold) {
		this.io.setIntField(this, 150, frame_skip_threshold);
		return this;
	}
	public final int frame_skip_threshold_$eq(int frame_skip_threshold) {
		frame_skip_threshold(frame_skip_threshold);
		return frame_skip_threshold;
	}
	/**
	 * frame skip factor<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(151) 
	public int frame_skip_factor() {
		return this.io.getIntField(this, 151);
	}
	/**
	 * frame skip factor<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(151) 
	public AVCodecContext frame_skip_factor(int frame_skip_factor) {
		this.io.setIntField(this, 151, frame_skip_factor);
		return this;
	}
	public final int frame_skip_factor_$eq(int frame_skip_factor) {
		frame_skip_factor(frame_skip_factor);
		return frame_skip_factor;
	}
	/**
	 * frame skip exponent<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(152) 
	public int frame_skip_exp() {
		return this.io.getIntField(this, 152);
	}
	/**
	 * frame skip exponent<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(152) 
	public AVCodecContext frame_skip_exp(int frame_skip_exp) {
		this.io.setIntField(this, 152, frame_skip_exp);
		return this;
	}
	public final int frame_skip_exp_$eq(int frame_skip_exp) {
		frame_skip_exp(frame_skip_exp);
		return frame_skip_exp;
	}
	/**
	 * frame skip comparison function<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(153) 
	public int frame_skip_cmp() {
		return this.io.getIntField(this, 153);
	}
	/**
	 * frame skip comparison function<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(153) 
	public AVCodecContext frame_skip_cmp(int frame_skip_cmp) {
		this.io.setIntField(this, 153, frame_skip_cmp);
		return this;
	}
	public final int frame_skip_cmp_$eq(int frame_skip_cmp) {
		frame_skip_cmp(frame_skip_cmp);
		return frame_skip_cmp;
	}
	/**
	 * Border processing masking, raises the quantizer for mbs on the borders<br>
	 * of the picture.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(154) 
	public float border_masking() {
		return this.io.getFloatField(this, 154);
	}
	/**
	 * Border processing masking, raises the quantizer for mbs on the borders<br>
	 * of the picture.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(154) 
	public AVCodecContext border_masking(float border_masking) {
		this.io.setFloatField(this, 154, border_masking);
		return this;
	}
	public final float border_masking_$eq(float border_masking) {
		border_masking(border_masking);
		return border_masking;
	}
	/**
	 * minimum MB lagrange multipler<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(155) 
	public int mb_lmin() {
		return this.io.getIntField(this, 155);
	}
	/**
	 * minimum MB lagrange multipler<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(155) 
	public AVCodecContext mb_lmin(int mb_lmin) {
		this.io.setIntField(this, 155, mb_lmin);
		return this;
	}
	public final int mb_lmin_$eq(int mb_lmin) {
		mb_lmin(mb_lmin);
		return mb_lmin;
	}
	/**
	 * maximum MB lagrange multipler<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(156) 
	public int mb_lmax() {
		return this.io.getIntField(this, 156);
	}
	/**
	 * maximum MB lagrange multipler<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(156) 
	public AVCodecContext mb_lmax(int mb_lmax) {
		this.io.setIntField(this, 156, mb_lmax);
		return this;
	}
	public final int mb_lmax_$eq(int mb_lmax) {
		mb_lmax(mb_lmax);
		return mb_lmax;
	}
	/**
	 * * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(157) 
	public int me_penalty_compensation() {
		return this.io.getIntField(this, 157);
	}
	/**
	 * * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(157) 
	public AVCodecContext me_penalty_compensation(int me_penalty_compensation) {
		this.io.setIntField(this, 157, me_penalty_compensation);
		return this;
	}
	public final int me_penalty_compensation_$eq(int me_penalty_compensation) {
		me_penalty_compensation(me_penalty_compensation);
		return me_penalty_compensation;
	}
	/**
	 * * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(161) 
	public int bidir_refine() {
		return this.io.getIntField(this, 161);
	}
	/**
	 * * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(161) 
	public AVCodecContext bidir_refine(int bidir_refine) {
		this.io.setIntField(this, 161, bidir_refine);
		return this;
	}
	public final int bidir_refine_$eq(int bidir_refine) {
		bidir_refine(bidir_refine);
		return bidir_refine;
	}
	/**
	 * * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(162) 
	public int brd_scale() {
		return this.io.getIntField(this, 162);
	}
	/**
	 * * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(162) 
	public AVCodecContext brd_scale(int brd_scale) {
		this.io.setIntField(this, 162, brd_scale);
		return this;
	}
	public final int brd_scale_$eq(int brd_scale) {
		brd_scale(brd_scale);
		return brd_scale;
	}
	/**
	 * constant rate factor - quality-based VBR - values ~correspond to qps<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(163) 
	public float crf() {
		return this.io.getFloatField(this, 163);
	}
	/**
	 * constant rate factor - quality-based VBR - values ~correspond to qps<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(163) 
	public AVCodecContext crf(float crf) {
		this.io.setFloatField(this, 163, crf);
		return this;
	}
	public final float crf_$eq(float crf) {
		crf(crf);
		return crf;
	}
	/**
	 * constant quantization parameter rate control method<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(164) 
	public int cqp() {
		return this.io.getIntField(this, 164);
	}
	/**
	 * constant quantization parameter rate control method<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(164) 
	public AVCodecContext cqp(int cqp) {
		this.io.setIntField(this, 164, cqp);
		return this;
	}
	public final int cqp_$eq(int cqp) {
		cqp(cqp);
		return cqp;
	}
	/**
	 * minimum GOP size<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(165) 
	public int keyint_min() {
		return this.io.getIntField(this, 165);
	}
	/**
	 * minimum GOP size<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(165) 
	public AVCodecContext keyint_min(int keyint_min) {
		this.io.setIntField(this, 165, keyint_min);
		return this;
	}
	public final int keyint_min_$eq(int keyint_min) {
		keyint_min(keyint_min);
		return keyint_min;
	}
	/**
	 * number of reference frames<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by lavc.
	 */
	@Field(166) 
	public int refs() {
		return this.io.getIntField(this, 166);
	}
	/**
	 * number of reference frames<br>
	 * - encoding: Set by user.<br>
	 * - decoding: Set by lavc.
	 */
	@Field(166) 
	public AVCodecContext refs(int refs) {
		this.io.setIntField(this, 166, refs);
		return this;
	}
	public final int refs_$eq(int refs) {
		refs(refs);
		return refs;
	}
	/**
	 * chroma qp offset from luma<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(167) 
	public int chromaoffset() {
		return this.io.getIntField(this, 167);
	}
	/**
	 * chroma qp offset from luma<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(167) 
	public AVCodecContext chromaoffset(int chromaoffset) {
		this.io.setIntField(this, 167, chromaoffset);
		return this;
	}
	public final int chromaoffset_$eq(int chromaoffset) {
		chromaoffset(chromaoffset);
		return chromaoffset;
	}
	/**
	 * Influences how often B-frames are used.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(168) 
	public int bframebias() {
		return this.io.getIntField(this, 168);
	}
	/**
	 * Influences how often B-frames are used.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(168) 
	public AVCodecContext bframebias(int bframebias) {
		this.io.setIntField(this, 168, bframebias);
		return this;
	}
	public final int bframebias_$eq(int bframebias) {
		bframebias(bframebias);
		return bframebias;
	}
	/**
	 * trellis RD quantization<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(169) 
	public int trellis() {
		return this.io.getIntField(this, 169);
	}
	/**
	 * trellis RD quantization<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(169) 
	public AVCodecContext trellis(int trellis) {
		this.io.setIntField(this, 169, trellis);
		return this;
	}
	public final int trellis_$eq(int trellis) {
		trellis(trellis);
		return trellis;
	}
	/**
	 * Reduce fluctuations in qp (before curve compression).<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(170) 
	public float complexityblur() {
		return this.io.getFloatField(this, 170);
	}
	/**
	 * Reduce fluctuations in qp (before curve compression).<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(170) 
	public AVCodecContext complexityblur(float complexityblur) {
		this.io.setFloatField(this, 170, complexityblur);
		return this;
	}
	public final float complexityblur_$eq(float complexityblur) {
		complexityblur(complexityblur);
		return complexityblur;
	}
	/**
	 * in-loop deblocking filter alphac0 parameter<br>
	 * alpha is in the range -6...6<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(171) 
	public int deblockalpha() {
		return this.io.getIntField(this, 171);
	}
	/**
	 * in-loop deblocking filter alphac0 parameter<br>
	 * alpha is in the range -6...6<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(171) 
	public AVCodecContext deblockalpha(int deblockalpha) {
		this.io.setIntField(this, 171, deblockalpha);
		return this;
	}
	public final int deblockalpha_$eq(int deblockalpha) {
		deblockalpha(deblockalpha);
		return deblockalpha;
	}
	/**
	 * in-loop deblocking filter beta parameter<br>
	 * beta is in the range -6...6<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(172) 
	public int deblockbeta() {
		return this.io.getIntField(this, 172);
	}
	/**
	 * in-loop deblocking filter beta parameter<br>
	 * beta is in the range -6...6<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(172) 
	public AVCodecContext deblockbeta(int deblockbeta) {
		this.io.setIntField(this, 172, deblockbeta);
		return this;
	}
	public final int deblockbeta_$eq(int deblockbeta) {
		deblockbeta(deblockbeta);
		return deblockbeta;
	}
	/**
	 * macroblock subpartition sizes to consider - p8x8, p4x4, b8x8, i8x8, i4x4<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(173) 
	public int partitions() {
		return this.io.getIntField(this, 173);
	}
	/**
	 * macroblock subpartition sizes to consider - p8x8, p4x4, b8x8, i8x8, i4x4<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(173) 
	public AVCodecContext partitions(int partitions) {
		this.io.setIntField(this, 173, partitions);
		return this;
	}
	public final int partitions_$eq(int partitions) {
		partitions(partitions);
		return partitions;
	}
	/**
	 * direct MV prediction mode - 0 (none), 1 (spatial), 2 (temporal), 3 (auto)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(174) 
	public int directpred() {
		return this.io.getIntField(this, 174);
	}
	/**
	 * direct MV prediction mode - 0 (none), 1 (spatial), 2 (temporal), 3 (auto)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(174) 
	public AVCodecContext directpred(int directpred) {
		this.io.setIntField(this, 174, directpred);
		return this;
	}
	public final int directpred_$eq(int directpred) {
		directpred(directpred);
		return directpred;
	}
	/**
	 * Audio cutoff bandwidth (0 means "automatic")<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(175) 
	public int cutoff() {
		return this.io.getIntField(this, 175);
	}
	/**
	 * Audio cutoff bandwidth (0 means "automatic")<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(175) 
	public AVCodecContext cutoff(int cutoff) {
		this.io.setIntField(this, 175, cutoff);
		return this;
	}
	public final int cutoff_$eq(int cutoff) {
		cutoff(cutoff);
		return cutoff;
	}
	/**
	 * Multiplied by qscale for each frame and added to scene_change_score.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(176) 
	public int scenechange_factor() {
		return this.io.getIntField(this, 176);
	}
	/**
	 * Multiplied by qscale for each frame and added to scene_change_score.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(176) 
	public AVCodecContext scenechange_factor(int scenechange_factor) {
		this.io.setIntField(this, 176, scenechange_factor);
		return this;
	}
	public final int scenechange_factor_$eq(int scenechange_factor) {
		scenechange_factor(scenechange_factor);
		return scenechange_factor;
	}
	/**
	 * * Note: Value depends upon the compare function used for fullpel ME.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(177) 
	public int mv0_threshold() {
		return this.io.getIntField(this, 177);
	}
	/**
	 * * Note: Value depends upon the compare function used for fullpel ME.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(177) 
	public AVCodecContext mv0_threshold(int mv0_threshold) {
		this.io.setIntField(this, 177, mv0_threshold);
		return this;
	}
	public final int mv0_threshold_$eq(int mv0_threshold) {
		mv0_threshold(mv0_threshold);
		return mv0_threshold;
	}
	/**
	 * Adjusts sensitivity of b_frame_strategy 1.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(178) 
	public int b_sensitivity() {
		return this.io.getIntField(this, 178);
	}
	/**
	 * Adjusts sensitivity of b_frame_strategy 1.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(178) 
	public AVCodecContext b_sensitivity(int b_sensitivity) {
		this.io.setIntField(this, 178, b_sensitivity);
		return this;
	}
	public final int b_sensitivity_$eq(int b_sensitivity) {
		b_sensitivity(b_sensitivity);
		return b_sensitivity;
	}
	/**
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(179) 
	public int compression_level() {
		return this.io.getIntField(this, 179);
	}
	/**
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(179) 
	public AVCodecContext compression_level(int compression_level) {
		this.io.setIntField(this, 179, compression_level);
		return this;
	}
	public final int compression_level_$eq(int compression_level) {
		compression_level(compression_level);
		return compression_level;
	}
	/**
	 * Sets whether to use LPC mode - used by FLAC encoder.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused<br>
	 * @deprecated Deprecated in favor of lpc_type and lpc_passes.
	 */
	@Field(180) 
	public int use_lpc() {
		return this.io.getIntField(this, 180);
	}
	/**
	 * Sets whether to use LPC mode - used by FLAC encoder.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused<br>
	 * @deprecated Deprecated in favor of lpc_type and lpc_passes.
	 */
	@Field(180) 
	public AVCodecContext use_lpc(int use_lpc) {
		this.io.setIntField(this, 180, use_lpc);
		return this;
	}
	public final int use_lpc_$eq(int use_lpc) {
		use_lpc(use_lpc);
		return use_lpc;
	}
	/**
	 * LPC coefficient precision - used by FLAC encoder<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(181) 
	public int lpc_coeff_precision() {
		return this.io.getIntField(this, 181);
	}
	/**
	 * LPC coefficient precision - used by FLAC encoder<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(181) 
	public AVCodecContext lpc_coeff_precision(int lpc_coeff_precision) {
		this.io.setIntField(this, 181, lpc_coeff_precision);
		return this;
	}
	public final int lpc_coeff_precision_$eq(int lpc_coeff_precision) {
		lpc_coeff_precision(lpc_coeff_precision);
		return lpc_coeff_precision;
	}
	/**
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(182) 
	public int min_prediction_order() {
		return this.io.getIntField(this, 182);
	}
	/**
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(182) 
	public AVCodecContext min_prediction_order(int min_prediction_order) {
		this.io.setIntField(this, 182, min_prediction_order);
		return this;
	}
	public final int min_prediction_order_$eq(int min_prediction_order) {
		min_prediction_order(min_prediction_order);
		return min_prediction_order;
	}
	/**
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(183) 
	public int max_prediction_order() {
		return this.io.getIntField(this, 183);
	}
	/**
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(183) 
	public AVCodecContext max_prediction_order(int max_prediction_order) {
		this.io.setIntField(this, 183, max_prediction_order);
		return this;
	}
	public final int max_prediction_order_$eq(int max_prediction_order) {
		max_prediction_order(max_prediction_order);
		return max_prediction_order;
	}
	/**
	 * search method for selecting prediction order<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(184) 
	public int prediction_order_method() {
		return this.io.getIntField(this, 184);
	}
	/**
	 * search method for selecting prediction order<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(184) 
	public AVCodecContext prediction_order_method(int prediction_order_method) {
		this.io.setIntField(this, 184, prediction_order_method);
		return this;
	}
	public final int prediction_order_method_$eq(int prediction_order_method) {
		prediction_order_method(prediction_order_method);
		return prediction_order_method;
	}
	/**
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(185) 
	public int min_partition_order() {
		return this.io.getIntField(this, 185);
	}
	/**
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(185) 
	public AVCodecContext min_partition_order(int min_partition_order) {
		this.io.setIntField(this, 185, min_partition_order);
		return this;
	}
	public final int min_partition_order_$eq(int min_partition_order) {
		min_partition_order(min_partition_order);
		return min_partition_order;
	}
	/**
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(186) 
	public int max_partition_order() {
		return this.io.getIntField(this, 186);
	}
	/**
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(186) 
	public AVCodecContext max_partition_order(int max_partition_order) {
		this.io.setIntField(this, 186, max_partition_order);
		return this;
	}
	public final int max_partition_order_$eq(int max_partition_order) {
		max_partition_order(max_partition_order);
		return max_partition_order;
	}
	/**
	 * GOP timecode frame start number, in non drop frame format<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(187) 
	public long timecode_frame_start() {
		return this.io.getLongField(this, 187);
	}
	/**
	 * GOP timecode frame start number, in non drop frame format<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(187) 
	public AVCodecContext timecode_frame_start(long timecode_frame_start) {
		this.io.setLongField(this, 187, timecode_frame_start);
		return this;
	}
	public final long timecode_frame_start_$eq(long timecode_frame_start) {
		timecode_frame_start(timecode_frame_start);
		return timecode_frame_start;
	}
	/**
	 * Decoder should decode to this many channels if it can (0 for default)<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.<br>
	 * @deprecated Deprecated in favor of request_channel_layout.
	 */
	@Field(188) 
	public int request_channels() {
		return this.io.getIntField(this, 188);
	}
	/**
	 * Decoder should decode to this many channels if it can (0 for default)<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.<br>
	 * @deprecated Deprecated in favor of request_channel_layout.
	 */
	@Field(188) 
	public AVCodecContext request_channels(int request_channels) {
		this.io.setIntField(this, 188, request_channels);
		return this;
	}
	public final int request_channels_$eq(int request_channels) {
		request_channels(request_channels);
		return request_channels;
	}
	/**
	 * Percentage of dynamic range compression to be applied by the decoder.<br>
	 * The default value is 1.0, corresponding to full compression.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	@Field(189) 
	public float drc_scale() {
		return this.io.getFloatField(this, 189);
	}
	/**
	 * Percentage of dynamic range compression to be applied by the decoder.<br>
	 * The default value is 1.0, corresponding to full compression.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	@Field(189) 
	public AVCodecContext drc_scale(float drc_scale) {
		this.io.setFloatField(this, 189, drc_scale);
		return this;
	}
	public final float drc_scale_$eq(float drc_scale) {
		drc_scale(drc_scale);
		return drc_scale;
	}
	/**
	 * opaque 64bit number (generally a PTS) that will be reordered and<br>
	 * output in AVFrame.reordered_opaque<br>
	 * @deprecated in favor of pkt_pts<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	@Field(190) 
	public long reordered_opaque() {
		return this.io.getLongField(this, 190);
	}
	/**
	 * opaque 64bit number (generally a PTS) that will be reordered and<br>
	 * output in AVFrame.reordered_opaque<br>
	 * @deprecated in favor of pkt_pts<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	@Field(190) 
	public AVCodecContext reordered_opaque(long reordered_opaque) {
		this.io.setLongField(this, 190, reordered_opaque);
		return this;
	}
	public final long reordered_opaque_$eq(long reordered_opaque) {
		reordered_opaque(reordered_opaque);
		return reordered_opaque;
	}
	/**
	 * Bits per sample/pixel of internal libavcodec pixel/sample format.<br>
	 * This field is applicable only when sample_fmt is AV_SAMPLE_FMT_S32.<br>
	 * - encoding: set by user.<br>
	 * - decoding: set by libavcodec.
	 */
	@Field(191) 
	public int bits_per_raw_sample() {
		return this.io.getIntField(this, 191);
	}
	/**
	 * Bits per sample/pixel of internal libavcodec pixel/sample format.<br>
	 * This field is applicable only when sample_fmt is AV_SAMPLE_FMT_S32.<br>
	 * - encoding: set by user.<br>
	 * - decoding: set by libavcodec.
	 */
	@Field(191) 
	public AVCodecContext bits_per_raw_sample(int bits_per_raw_sample) {
		this.io.setIntField(this, 191, bits_per_raw_sample);
		return this;
	}
	public final int bits_per_raw_sample_$eq(int bits_per_raw_sample) {
		bits_per_raw_sample(bits_per_raw_sample);
		return bits_per_raw_sample;
	}
	/**
	 * Audio channel layout.<br>
	 * - encoding: set by user.<br>
	 * - decoding: set by libavcodec.
	 */
	@Field(192) 
	public long channel_layout() {
		return this.io.getLongField(this, 192);
	}
	/**
	 * Audio channel layout.<br>
	 * - encoding: set by user.<br>
	 * - decoding: set by libavcodec.
	 */
	@Field(192) 
	public AVCodecContext channel_layout(long channel_layout) {
		this.io.setLongField(this, 192, channel_layout);
		return this;
	}
	public final long channel_layout_$eq(long channel_layout) {
		channel_layout(channel_layout);
		return channel_layout;
	}
	/**
	 * Request decoder to use this channel layout if it can (0 for default)<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	@Field(193) 
	public long request_channel_layout() {
		return this.io.getLongField(this, 193);
	}
	/**
	 * Request decoder to use this channel layout if it can (0 for default)<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user.
	 */
	@Field(193) 
	public AVCodecContext request_channel_layout(long request_channel_layout) {
		this.io.setLongField(this, 193, request_channel_layout);
		return this;
	}
	public final long request_channel_layout_$eq(long request_channel_layout) {
		request_channel_layout(request_channel_layout);
		return request_channel_layout;
	}
	/**
	 * Ratecontrol attempt to use, at maximum, <value> of what can be used without an underflow.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused.
	 */
	@Field(194) 
	public float rc_max_available_vbv_use() {
		return this.io.getFloatField(this, 194);
	}
	/**
	 * Ratecontrol attempt to use, at maximum, <value> of what can be used without an underflow.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused.
	 */
	@Field(194) 
	public AVCodecContext rc_max_available_vbv_use(float rc_max_available_vbv_use) {
		this.io.setFloatField(this, 194, rc_max_available_vbv_use);
		return this;
	}
	public final float rc_max_available_vbv_use_$eq(float rc_max_available_vbv_use) {
		rc_max_available_vbv_use(rc_max_available_vbv_use);
		return rc_max_available_vbv_use;
	}
	/**
	 * Ratecontrol attempt to use, at least, <value> times the amount needed to prevent a vbv overflow.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused.
	 */
	@Field(195) 
	public float rc_min_vbv_overflow_use() {
		return this.io.getFloatField(this, 195);
	}
	/**
	 * Ratecontrol attempt to use, at least, <value> times the amount needed to prevent a vbv overflow.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused.
	 */
	@Field(195) 
	public AVCodecContext rc_min_vbv_overflow_use(float rc_min_vbv_overflow_use) {
		this.io.setFloatField(this, 195, rc_min_vbv_overflow_use);
		return this;
	}
	public final float rc_min_vbv_overflow_use_$eq(float rc_min_vbv_overflow_use) {
		rc_min_vbv_overflow_use(rc_min_vbv_overflow_use);
		return rc_min_vbv_overflow_use;
	}
	/**
	 * Hardware accelerator in use<br>
	 * - encoding: unused.<br>
	 * - decoding: Set by libavcodec<br>
	 * C type : AVHWAccel*
	 */
	@Field(196) 
	public Pointer<AVHWAccel > hwaccel() {
		return this.io.getPointerField(this, 196);
	}
	/**
	 * Hardware accelerator in use<br>
	 * - encoding: unused.<br>
	 * - decoding: Set by libavcodec<br>
	 * C type : AVHWAccel*
	 */
	@Field(196) 
	public AVCodecContext hwaccel(Pointer<AVHWAccel > hwaccel) {
		this.io.setPointerField(this, 196, hwaccel);
		return this;
	}
	/// C type : AVHWAccel*
	public final Pointer<AVHWAccel > hwaccel_$eq(Pointer<AVHWAccel > hwaccel) {
		hwaccel(hwaccel);
		return hwaccel;
	}
	/**
	 * For some codecs, the time base is closer to the field rate than the frame rate.<br>
	 * Most notably, H.264 and MPEG-2 specify time_base as half of frame duration<br>
	 * if no telecine is used ...<br>
	 * * Set to time_base ticks per frame. Default 1, e.g., H.264/MPEG-2 set it to 2.
	 */
	@Field(197) 
	public int ticks_per_frame() {
		return this.io.getIntField(this, 197);
	}
	/**
	 * For some codecs, the time base is closer to the field rate than the frame rate.<br>
	 * Most notably, H.264 and MPEG-2 specify time_base as half of frame duration<br>
	 * if no telecine is used ...<br>
	 * * Set to time_base ticks per frame. Default 1, e.g., H.264/MPEG-2 set it to 2.
	 */
	@Field(197) 
	public AVCodecContext ticks_per_frame(int ticks_per_frame) {
		this.io.setIntField(this, 197, ticks_per_frame);
		return this;
	}
	public final int ticks_per_frame_$eq(int ticks_per_frame) {
		ticks_per_frame(ticks_per_frame);
		return ticks_per_frame;
	}
	/**
	 * Hardware accelerator context.<br>
	 * For some hardware accelerators, a global context needs to be<br>
	 * provided by the user. In that case, this holds display-dependent<br>
	 * data FFmpeg cannot instantiate itself. Please refer to the<br>
	 * FFmpeg HW accelerator documentation to know how to fill this<br>
	 * is. e.g. for VA API, this is a struct vaapi_context.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user<br>
	 * C type : void*
	 */
	@Field(198) 
	public Pointer<? > hwaccel_context() {
		return this.io.getPointerField(this, 198);
	}
	/**
	 * Hardware accelerator context.<br>
	 * For some hardware accelerators, a global context needs to be<br>
	 * provided by the user. In that case, this holds display-dependent<br>
	 * data FFmpeg cannot instantiate itself. Please refer to the<br>
	 * FFmpeg HW accelerator documentation to know how to fill this<br>
	 * is. e.g. for VA API, this is a struct vaapi_context.<br>
	 * - encoding: unused<br>
	 * - decoding: Set by user<br>
	 * C type : void*
	 */
	@Field(198) 
	public AVCodecContext hwaccel_context(Pointer<? > hwaccel_context) {
		this.io.setPointerField(this, 198, hwaccel_context);
		return this;
	}
	/// C type : void*
	public final Pointer<? > hwaccel_context_$eq(Pointer<? > hwaccel_context) {
		hwaccel_context(hwaccel_context);
		return hwaccel_context;
	}
	/**
	 * The codec may call this to execute several independent things.<br>
	 * It will return only after finishing all tasks.<br>
	 * The user may replace this with some multithreaded implementation,<br>
	 * the default implementation will execute the parts serially.<br>
	 * Also see avcodec_thread_init and e.g. the --enable-pthread configure option.<br>
	 * @param c context passed also to func<br>
	 * @param count the number of things to execute<br>
	 * @param arg2 argument passed unchanged to func<br>
	 * @param ret return values of executed functions, must have space for "count" values. May be NULL.<br>
	 * @param func function that will be called count times, with jobnr from 0 to count-1.<br>
	 *             threadnr will be in the range 0 to c->thread_count-1 < MAX_THREADS and so that no<br>
	 *             two instances of func executing at the same time will have the same threadnr.<br>
	 * @return always 0 currently, but code should handle a future improvement where when any call to func<br>
	 *         returns < 0 no further calls to func may be done and < 0 is returned.<br>
	 * - encoding: Set by libavcodec, user can override.<br>
	 * - decoding: Set by libavcodec, user can override.<br>
	 * C type : execute2_callback
	 */
	@Field(204) 
	public Pointer<AVCodecContext.execute2_callback > execute2() {
		return this.io.getPointerField(this, 204);
	}
	/**
	 * The codec may call this to execute several independent things.<br>
	 * It will return only after finishing all tasks.<br>
	 * The user may replace this with some multithreaded implementation,<br>
	 * the default implementation will execute the parts serially.<br>
	 * Also see avcodec_thread_init and e.g. the --enable-pthread configure option.<br>
	 * @param c context passed also to func<br>
	 * @param count the number of things to execute<br>
	 * @param arg2 argument passed unchanged to func<br>
	 * @param ret return values of executed functions, must have space for "count" values. May be NULL.<br>
	 * @param func function that will be called count times, with jobnr from 0 to count-1.<br>
	 *             threadnr will be in the range 0 to c->thread_count-1 < MAX_THREADS and so that no<br>
	 *             two instances of func executing at the same time will have the same threadnr.<br>
	 * @return always 0 currently, but code should handle a future improvement where when any call to func<br>
	 *         returns < 0 no further calls to func may be done and < 0 is returned.<br>
	 * - encoding: Set by libavcodec, user can override.<br>
	 * - decoding: Set by libavcodec, user can override.<br>
	 * C type : execute2_callback
	 */
	@Field(204) 
	public AVCodecContext execute2(Pointer<AVCodecContext.execute2_callback > execute2) {
		this.io.setPointerField(this, 204, execute2);
		return this;
	}
	/// C type : execute2_callback
	public final Pointer<AVCodecContext.execute2_callback > execute2_$eq(Pointer<AVCodecContext.execute2_callback > execute2) {
		execute2(execute2);
		return execute2;
	}
	/**
	 * explicit P-frame weighted prediction analysis method<br>
	 * 0: off<br>
	 * 1: fast blind weighting (one reference duplicate with -1 offset)<br>
	 * 2: smart weighting (full fade detection analysis)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(205) 
	public int weighted_p_pred() {
		return this.io.getIntField(this, 205);
	}
	/**
	 * explicit P-frame weighted prediction analysis method<br>
	 * 0: off<br>
	 * 1: fast blind weighting (one reference duplicate with -1 offset)<br>
	 * 2: smart weighting (full fade detection analysis)<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(205) 
	public AVCodecContext weighted_p_pred(int weighted_p_pred) {
		this.io.setIntField(this, 205, weighted_p_pred);
		return this;
	}
	public final int weighted_p_pred_$eq(int weighted_p_pred) {
		weighted_p_pred(weighted_p_pred);
		return weighted_p_pred;
	}
	/**
	 * AQ mode<br>
	 * 0: Disabled<br>
	 * 1: Variance AQ (complexity mask)<br>
	 * 2: Auto-variance AQ (experimental)<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused
	 */
	@Field(206) 
	public int aq_mode() {
		return this.io.getIntField(this, 206);
	}
	/**
	 * AQ mode<br>
	 * 0: Disabled<br>
	 * 1: Variance AQ (complexity mask)<br>
	 * 2: Auto-variance AQ (experimental)<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused
	 */
	@Field(206) 
	public AVCodecContext aq_mode(int aq_mode) {
		this.io.setIntField(this, 206, aq_mode);
		return this;
	}
	public final int aq_mode_$eq(int aq_mode) {
		aq_mode(aq_mode);
		return aq_mode;
	}
	/**
	 * AQ strength<br>
	 * Reduces blocking and blurring in flat and textured areas.<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused
	 */
	@Field(207) 
	public float aq_strength() {
		return this.io.getFloatField(this, 207);
	}
	/**
	 * AQ strength<br>
	 * Reduces blocking and blurring in flat and textured areas.<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused
	 */
	@Field(207) 
	public AVCodecContext aq_strength(float aq_strength) {
		this.io.setFloatField(this, 207, aq_strength);
		return this;
	}
	public final float aq_strength_$eq(float aq_strength) {
		aq_strength(aq_strength);
		return aq_strength;
	}
	/**
	 * PSY RD<br>
	 * Strength of psychovisual optimization<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused
	 */
	@Field(208) 
	public float psy_rd() {
		return this.io.getFloatField(this, 208);
	}
	/**
	 * PSY RD<br>
	 * Strength of psychovisual optimization<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused
	 */
	@Field(208) 
	public AVCodecContext psy_rd(float psy_rd) {
		this.io.setFloatField(this, 208, psy_rd);
		return this;
	}
	public final float psy_rd_$eq(float psy_rd) {
		psy_rd(psy_rd);
		return psy_rd;
	}
	/**
	 * PSY trellis<br>
	 * Strength of psychovisual optimization<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused
	 */
	@Field(209) 
	public float psy_trellis() {
		return this.io.getFloatField(this, 209);
	}
	/**
	 * PSY trellis<br>
	 * Strength of psychovisual optimization<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused
	 */
	@Field(209) 
	public AVCodecContext psy_trellis(float psy_trellis) {
		this.io.setFloatField(this, 209, psy_trellis);
		return this;
	}
	public final float psy_trellis_$eq(float psy_trellis) {
		psy_trellis(psy_trellis);
		return psy_trellis;
	}
	/**
	 * RC lookahead<br>
	 * Number of frames for frametype and ratecontrol lookahead<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused
	 */
	@Field(210) 
	public int rc_lookahead() {
		return this.io.getIntField(this, 210);
	}
	/**
	 * RC lookahead<br>
	 * Number of frames for frametype and ratecontrol lookahead<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused
	 */
	@Field(210) 
	public AVCodecContext rc_lookahead(int rc_lookahead) {
		this.io.setIntField(this, 210, rc_lookahead);
		return this;
	}
	public final int rc_lookahead_$eq(int rc_lookahead) {
		rc_lookahead(rc_lookahead);
		return rc_lookahead;
	}
	/**
	 * Constant rate factor maximum<br>
	 * With CRF encoding mode and VBV restrictions enabled, prevents quality from being worse<br>
	 * than crf_max, even if doing so would violate VBV restrictions.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(211) 
	public float crf_max() {
		return this.io.getFloatField(this, 211);
	}
	/**
	 * Constant rate factor maximum<br>
	 * With CRF encoding mode and VBV restrictions enabled, prevents quality from being worse<br>
	 * than crf_max, even if doing so would violate VBV restrictions.<br>
	 * - encoding: Set by user.<br>
	 * - decoding: unused
	 */
	@Field(211) 
	public AVCodecContext crf_max(float crf_max) {
		this.io.setFloatField(this, 211, crf_max);
		return this;
	}
	public final float crf_max_$eq(float crf_max) {
		crf_max(crf_max);
		return crf_max;
	}
	@Field(212) 
	public int log_level_offset() {
		return this.io.getIntField(this, 212);
	}
	@Field(212) 
	public AVCodecContext log_level_offset(int log_level_offset) {
		this.io.setIntField(this, 212, log_level_offset);
		return this;
	}
	public final int log_level_offset_$eq(int log_level_offset) {
		log_level_offset(log_level_offset);
		return log_level_offset;
	}
	/**
	 * Number of passes to use for Cholesky factorization during LPC analysis<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused
	 */
	@Field(214) 
	public int lpc_passes() {
		return this.io.getIntField(this, 214);
	}
	/**
	 * Number of passes to use for Cholesky factorization during LPC analysis<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused
	 */
	@Field(214) 
	public AVCodecContext lpc_passes(int lpc_passes) {
		this.io.setIntField(this, 214, lpc_passes);
		return this;
	}
	public final int lpc_passes_$eq(int lpc_passes) {
		lpc_passes(lpc_passes);
		return lpc_passes;
	}
	/**
	 * Number of slices.<br>
	 * Indicates number of picture subdivisions. Used for parallelized<br>
	 * decoding.<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused
	 */
	@Field(215) 
	public int slices() {
		return this.io.getIntField(this, 215);
	}
	/**
	 * Number of slices.<br>
	 * Indicates number of picture subdivisions. Used for parallelized<br>
	 * decoding.<br>
	 * - encoding: Set by user<br>
	 * - decoding: unused
	 */
	@Field(215) 
	public AVCodecContext slices(int slices) {
		this.io.setIntField(this, 215, slices);
		return this;
	}
	public final int slices_$eq(int slices) {
		slices(slices);
		return slices;
	}
	/**
	 * Header containing style information for text subtitles.<br>
	 * For SUBTITLE_ASS subtitle type, it should contain the whole ASS<br>
	 * [Script Info] and [V4+ Styles] section, plus the [Events] line and<br>
	 * the Format line following. It shouldn't include any Dialogue line.<br>
	 * - encoding: Set/allocated/freed by user (before avcodec_open())<br>
	 * - decoding: Set/allocated/freed by libavcodec (by avcodec_open())<br>
	 * C type : uint8_t*
	 */
	@Field(216) 
	public Pointer<Byte > subtitle_header() {
		return this.io.getPointerField(this, 216);
	}
	/**
	 * Header containing style information for text subtitles.<br>
	 * For SUBTITLE_ASS subtitle type, it should contain the whole ASS<br>
	 * [Script Info] and [V4+ Styles] section, plus the [Events] line and<br>
	 * the Format line following. It shouldn't include any Dialogue line.<br>
	 * - encoding: Set/allocated/freed by user (before avcodec_open())<br>
	 * - decoding: Set/allocated/freed by libavcodec (by avcodec_open())<br>
	 * C type : uint8_t*
	 */
	@Field(216) 
	public AVCodecContext subtitle_header(Pointer<Byte > subtitle_header) {
		this.io.setPointerField(this, 216, subtitle_header);
		return this;
	}
	/// C type : uint8_t*
	public final Pointer<Byte > subtitle_header_$eq(Pointer<Byte > subtitle_header) {
		subtitle_header(subtitle_header);
		return subtitle_header;
	}
	@Field(217) 
	public int subtitle_header_size() {
		return this.io.getIntField(this, 217);
	}
	@Field(217) 
	public AVCodecContext subtitle_header_size(int subtitle_header_size) {
		this.io.setIntField(this, 217, subtitle_header_size);
		return this;
	}
	public final int subtitle_header_size_$eq(int subtitle_header_size) {
		subtitle_header_size(subtitle_header_size);
		return subtitle_header_size;
	}
	/**
	 * Current packet as passed into the decoder, to avoid having<br>
	 * to pass the packet into every function. Currently only valid<br>
	 * inside lavc and get/release_buffer callbacks.<br>
	 * - decoding: set by avcodec_decode_*, read by get_buffer() for setting pkt_pts<br>
	 * - encoding: unused<br>
	 * C type : AVPacket*
	 */
	@Field(218) 
	public Pointer<AVPacket > pkt() {
		return this.io.getPointerField(this, 218);
	}
	/**
	 * Current packet as passed into the decoder, to avoid having<br>
	 * to pass the packet into every function. Currently only valid<br>
	 * inside lavc and get/release_buffer callbacks.<br>
	 * - decoding: set by avcodec_decode_*, read by get_buffer() for setting pkt_pts<br>
	 * - encoding: unused<br>
	 * C type : AVPacket*
	 */
	@Field(218) 
	public AVCodecContext pkt(Pointer<AVPacket > pkt) {
		this.io.setPointerField(this, 218, pkt);
		return this;
	}
	/// C type : AVPacket*
	public final Pointer<AVPacket > pkt_$eq(Pointer<AVPacket > pkt) {
		pkt(pkt);
		return pkt;
	}
	/// <i>native declaration : libavcodec/avcodec.h</i>
	public static abstract class draw_horiz_band_callback extends Callback<draw_horiz_band_callback > {
		public abstract void apply(Pointer<AVCodecContext > s, Pointer<AVFrame > src, Pointer<Integer > offset, int y, int type, int height);
	};
	/// <i>native declaration : libavcodec/avcodec.h</i>
	public static abstract class rtp_callback_callback extends Callback<rtp_callback_callback > {
		public abstract void apply(Pointer<AVCodecContext > avctx, Pointer<? > data, int size, int mb_nb);
	};
	/// <i>native declaration : libavcodec/avcodec.h</i>
	public static abstract class get_buffer_callback extends Callback<get_buffer_callback > {
		public abstract int apply(Pointer<AVCodecContext > c, Pointer<AVFrame > pic);
	};
	/// <i>native declaration : libavcodec/avcodec.h</i>
	public static abstract class release_buffer_callback extends Callback<release_buffer_callback > {
		public abstract void apply(Pointer<AVCodecContext > c, Pointer<AVFrame > pic);
	};
	/// <i>native declaration : libavcodec/avcodec.h</i>
	public static abstract class get_format_callback extends Callback<get_format_callback > {
		public abstract PixelFormat apply(Pointer<AVCodecContext > s, Pointer<PixelFormat > fmt);
	};
	/// <i>native declaration : libavcodec/avcodec.h</i>
	public static abstract class reget_buffer_callback extends Callback<reget_buffer_callback > {
		public abstract int apply(Pointer<AVCodecContext > c, Pointer<AVFrame > pic);
	};
	/// <i>native declaration : libavcodec/avcodec.h:2127</i>
	public static abstract class execute_callback_arg1_func_callback extends Callback<execute_callback_arg1_func_callback > {
		public abstract int apply(Pointer<AVCodecContext > c2, Pointer<? > arg);
	};
	/// <i>native declaration : libavcodec/avcodec.h</i>
	public static abstract class execute_callback extends Callback<execute_callback > {
		public abstract int apply(Pointer<AVCodecContext > c, Pointer<AVCodecContext.execute_callback_arg1_func_callback > arg1, Pointer<? > arg2, Pointer<Integer > ret, int count, int size);
	};
	/// <i>native declaration : libavcodec/avcodec.h:2650</i>
	public static abstract class execute2_callback_arg1_func_callback extends Callback<execute2_callback_arg1_func_callback > {
		public abstract int apply(Pointer<AVCodecContext > c2, Pointer<? > arg, int jobnr, int threadnr);
	};
	/// <i>native declaration : libavcodec/avcodec.h</i>
	public static abstract class execute2_callback extends Callback<execute2_callback > {
		public abstract int apply(Pointer<AVCodecContext > c, Pointer<AVCodecContext.execute2_callback_arg1_func_callback > arg1, Pointer<? > arg2, Pointer<Integer > ret, int count);
	};
}
